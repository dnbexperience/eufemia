{"version":3,"file":"26ede9db72205ff5ab333e36323a3ec6d3881de9-097937c4b44da2dec36e.js","mappings":"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","sources":["webpack://dnb-design-system-portal/../dnb-eufemia/src/elements/typography/Lead.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/elements/Lead.ts","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Field/Boolean/Boolean.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Field/Name/Name.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/InputMasked.ts","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Field/String/String.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Field/Toggle/Toggle.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Form/ButtonRow/ButtonRow.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Form/Section/Section.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Form/SubmitButton/SubmitButton.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/HeightAnimation.ts","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/Form/Visibility/Visibility.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/extensions/forms/hooks/useErrorMessage.ts","webpack://dnb-design-system-portal/../dnb-eufemia/src/icons/dnb/send.tsx","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/InputMaskedContext.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/addons/createNumberMask.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/InputMaskedUtils.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/InputMaskedHooks.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/InputMaskedElement.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/InputMasked.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/text-mask/InputModeNumber.ts","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/TextMask.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/text-mask/constants.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/text-mask/adjustCaretPosition.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/text-mask/conformToMask.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/text-mask/createTextMaskInputElement.js","webpack://dnb-design-system-portal/../dnb-eufemia/src/components/input-masked/text-mask/utilities.js"],"sourcesContent":["/**\n * HTML Element\n *\n */\nimport React from 'react'\nimport P, { PProps } from './P'\nimport classnames from 'classnames'\n\nconst Lead = ({ className, ...rest }: PProps) => (\n  <P className={classnames('dnb-p--lead', className)} {...rest} />\n)\n\nLead._supportsSpacingProps = true\n\nexport default Lead\n","/**\n * This file is created manually\n * You can change the content\n *\n */\n\nimport Lead from './typography/Lead'\nexport * from './typography/Lead'\nexport default Lead\n","import React from 'react'\nimport ToggleField, { Props as ToggleFieldProps } from '../Toggle'\nimport useTranslation from '../../hooks/useTranslation'\nimport { FieldProps, Path } from '../../types'\n\ntype BooleanProps = {\n  trueText?: string\n  falseText?: string\n  variant?: ToggleFieldProps['variant']\n  dependencePaths?: never\n}\ntype NeverBooleanProps = {\n  // eslint-disable-next-line no-unused-vars\n  [K in keyof Partial<Omit<BooleanProps, 'dependencePaths'>>]: never\n}\nexport type IndeterminateProps = FieldProps<unknown> & {\n  dependencePaths: Array<Path>\n} & NeverBooleanProps\nexport type Props = FieldProps<unknown> & BooleanProps\n\nfunction BooleanComponent(props: Props | IndeterminateProps) {\n  const { trueText, falseText, ...restProps } = props\n  const translations = useTranslation().BooleanField\n\n  return (\n    <ToggleField\n      {...(restProps as ToggleFieldProps)}\n      valueOn={true}\n      valueOff={false}\n      textOn={trueText ?? translations.yes}\n      textOff={falseText ?? translations.no}\n      valueType=\"boolean\"\n    />\n  )\n}\n\nBooleanComponent._supportsSpacingProps = true\nexport default BooleanComponent\n","import React from 'react'\nimport StringField, { Props as StringFieldProps } from '../String'\nimport useErrorMessage from '../../hooks/useErrorMessage'\nimport useTranslation from '../../hooks/useTranslation'\n\nexport type Props = StringFieldProps\n\nfunction Name(props: Props) {\n  const StringFieldProps: Props = {\n    trim: true,\n    autoComplete: 'name',\n    pattern: '^[\\\\p{L}\\\\p{M} \\\\-]+$',\n    ...props,\n  }\n\n  return <StringField {...StringFieldProps} />\n}\nName._supportsSpacingProps = true\n\nName.First = function FirstName(props: Props) {\n  const translations = useTranslation().FirstName\n  const errorMessages = useErrorMessage(props.path, props.errorMessages, {\n    required: translations.errorRequired,\n    pattern: translations.errorPattern,\n  })\n\n  const nameProps: Props = {\n    label: translations.label,\n    autoComplete: 'given-name',\n    ...props,\n    errorMessages,\n  }\n\n  return <Name {...nameProps} />\n}\nName.First['_supportsSpacingProps'] = true\n\nName.Last = function LastName(props: Props) {\n  const translations = useTranslation().LastName\n  const errorMessages = useErrorMessage(props.path, props.errorMessages, {\n    required: translations.errorRequired,\n    pattern: translations.errorPattern,\n  })\n\n  const nameProps: Props = {\n    label: translations.label,\n    autoComplete: 'family-name',\n    ...props,\n    errorMessages,\n  }\n\n  return <Name {...nameProps} />\n}\nName.First['_supportsSpacingProps'] = true\n\nName.Company = function CompanyName(props: Props) {\n  const translations = useTranslation().CompanyName\n  const errorMessages = useErrorMessage(props.path, props.errorMessages, {\n    required: translations.errorRequired,\n  })\n\n  const StringFieldProps: Props = {\n    label: translations.label,\n    pattern: undefined,\n    autoComplete: 'organization',\n    ...props,\n    errorMessages,\n  }\n\n  return <Name {...StringFieldProps} />\n}\nName.First['_supportsSpacingProps'] = true\n\nexport default Name\n","/**\n * ATTENTION: This file is auto generated by using \"prepareTemplates\".\n * Do not change the content!\n *\n */\n\n/**\n * Library Index input-masked to autogenerate all the components and extensions\n * Used by \"prepareInputMaskeds\"\n */\n\nimport InputMasked from './input-masked/InputMasked'\nexport * from './input-masked/InputMasked'\nexport default InputMasked\n","import React, { useContext, useMemo, useCallback } from 'react'\nimport classnames from 'classnames'\nimport { HelpButton, Input, Textarea } from '../../../../components'\nimport { InputProps } from '../../../../components/input/Input'\nimport InputMasked, {\n  InputMaskedProps,\n} from '../../../../components/InputMasked'\nimport { TextareaProps } from '../../../../components/Textarea'\nimport FieldBlockContext from '../../FieldBlock/FieldBlockContext'\nimport FieldBlock from '../../FieldBlock'\nimport { useFieldProps } from '../../hooks'\nimport { pickSpacingProps } from '../../../../components/flex/utils'\nimport { toCapitalized } from '../../../../shared/component-helper'\nimport type { TextCounterProps } from '../../../../fragments/TextCounter'\nimport type {\n  FieldProps,\n  FieldHelpProps,\n  CustomErrorMessages,\n  AllJSONSchemaVersions,\n  FieldBlockWidth,\n} from '../../types'\nimport useErrorMessage from '../../hooks/useErrorMessage'\nimport useTranslation from '../../hooks/useTranslation'\n\ninterface ErrorMessages extends CustomErrorMessages {\n  required?: string\n  schema?: string\n  minLength?: string\n  maxLength?: string\n  pattern?: string\n}\nexport type Props = FieldHelpProps &\n  FieldProps<string, undefined | string, ErrorMessages> & {\n    // - Shared props\n    multiline?: boolean\n    inputClassName?: string\n    innerRef?: React.RefObject<HTMLInputElement | HTMLTextAreaElement>\n    width?: FieldBlockWidth\n    size?: InputProps['size'] | TextareaProps['size']\n    keepPlaceholder?: InputProps['keep_placeholder']\n\n    // - Validation\n    minLength?: number\n    maxLength?: number\n    pattern?: string\n\n    // - Input props\n    type?: InputProps['type']\n    align?: InputProps['align']\n    selectall?: InputProps['selectall']\n    clear?: boolean\n    mask?: InputMaskedProps['mask']\n    leftIcon?: string\n    rightIcon?: string\n    submitElement?: InputProps['submit_element']\n    capitalize?: boolean\n    trim?: boolean\n\n    // - Textarea props\n    rows?: TextareaProps['rows']\n    autoresizeMaxRows?: TextareaProps['autoresize_max_rows']\n    autoresize?: TextareaProps['autoresize']\n    characterCounter?: Omit<TextCounterProps, 'text'> | number\n\n    // - Html props\n    autoComplete?: HTMLInputElement['autocomplete']\n    inputMode?: React.HTMLAttributes<HTMLInputElement>['inputMode']\n    autoCorrect?: React.HTMLAttributes<HTMLInputElement>['autoCorrect']\n    spellCheck?: React.HTMLAttributes<HTMLInputElement>['spellCheck']\n    autoFocus?: React.HTMLAttributes<HTMLInputElement>['autoFocus']\n    autoCapitalize?: React.HTMLAttributes<HTMLInputElement>['autoCapitalize']\n  }\n\nfunction StringComponent(props: Props) {\n  const fieldBlockContext = useContext(FieldBlockContext)\n  const translations = useTranslation()\n\n  const errorMessages = useErrorMessage(props.path, props.errorMessages, {\n    required: translations.Field.errorRequired,\n    minLength: translations.StringField.errorMinLength,\n    maxLength: translations.StringField.errorMaxLength,\n    pattern: translations.Field.errorPattern,\n  })\n\n  const schema = useMemo<AllJSONSchemaVersions>(\n    () =>\n      props.schema ?? {\n        type: 'string',\n        minLength: props.minLength,\n        maxLength: props.maxLength,\n        pattern: props.pattern,\n      },\n    [props.schema, props.minLength, props.maxLength, props.pattern]\n  )\n  const fromInput = useCallback(\n    (event: { value: string; cleanedValue?: string }) => {\n      if (typeof event === 'string') {\n        event = { value: event }\n      }\n      if (event?.value === '') {\n        return props.emptyValue\n      }\n      // Cleaned value for masked\n      return event?.cleanedValue ?? event?.value\n    },\n    [props.emptyValue]\n  )\n  const toEvent = useCallback(\n    (value: string, type: string) => {\n      if (props.trim && type === 'onBlur') {\n        const spaces = '[\\\\s ]'\n        if (new RegExp(`^${spaces}|${spaces}$`).test(value)) {\n          value = value.replace(\n            new RegExp(`^${spaces}+|${spaces}+$`, 'g'),\n            ''\n          )\n          handleChange(value)\n        }\n      }\n      return value\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [props.trim]\n  )\n  const transform = props.transformValue\n  const transformValue = useCallback(\n    (value: string) => {\n      if (props.capitalize) {\n        value = toCapitalized(String(value || ''))\n      }\n      return transform?.(value) || value\n    },\n    [props.capitalize, transform]\n  )\n\n  const preparedProps: Props = {\n    ...props,\n    errorMessages,\n    schema,\n    fromInput,\n    toEvent,\n    transformValue,\n    width:\n      props.width ??\n      (fieldBlockContext?.composition ? 'stretch' : 'large'),\n  }\n\n  const {\n    id,\n    name,\n    className,\n    innerRef,\n    inputClassName,\n    layout,\n    placeholder,\n    label,\n    labelDescription,\n    value,\n    info,\n    warning,\n    error,\n    hasError,\n    disabled,\n    help,\n    multiline,\n    mask,\n    leftIcon,\n    rightIcon,\n    width,\n    htmlAttributes,\n    submitElement,\n\n    // - Input props\n    type,\n    clear,\n    align,\n    size,\n    selectall,\n    keepPlaceholder,\n\n    // - Textarea props\n    rows,\n    autoresizeMaxRows = 6,\n    autoresize = true,\n    characterCounter,\n\n    // - Html props\n    autoComplete,\n    inputMode,\n    autoCorrect,\n    spellCheck,\n    autoFocus,\n    autoCapitalize,\n\n    // - Events\n    handleFocus,\n    handleBlur,\n    handleChange,\n  } = useFieldProps(preparedProps)\n\n  const transformInstantly = useCallback(\n    (value: string) => (props.capitalize ? toCapitalized(value) : value),\n    [props.capitalize]\n  )\n\n  const cn = classnames('dnb-forms-field-string__input', inputClassName)\n\n  const sharedProps: InputProps & TextareaProps = {\n    id,\n    name,\n    autoComplete,\n    autoCorrect,\n    spellCheck,\n    autoFocus,\n    autoCapitalize,\n    inputMode,\n    className: cn,\n    placeholder,\n    suffix: help ? (\n      <HelpButton title={help.title}>{help.content}</HelpButton>\n    ) : undefined,\n    on_focus: handleFocus,\n    on_blur: handleBlur,\n    on_change: handleChange,\n    disabled,\n    ...htmlAttributes,\n    stretch: Boolean(\n      width !== undefined || fieldBlockContext?.composition\n    ),\n    inner_ref: innerRef,\n    status: hasError ? 'error' : undefined,\n    value: transformInstantly(value?.toString() ?? ''),\n  }\n\n  const textareaProps: TextareaProps = {\n    keepPlaceholder,\n    rows,\n    autoresize_max_rows: autoresizeMaxRows,\n    autoresize,\n    characterCounter,\n  }\n\n  const inputProps: InputProps = {\n    type: type,\n    clear: clear,\n    size: size,\n    align: align,\n    selectall: selectall,\n    icon: leftIcon ?? rightIcon,\n    icon_position: rightIcon && !leftIcon ? 'right' : undefined,\n    submit_element: submitElement,\n    keep_placeholder: keepPlaceholder,\n  }\n\n  const fieldSectionProps = {\n    className: classnames('dnb-forms-field-string', className),\n    forId: id,\n    layout,\n    label,\n    labelDescription,\n    info,\n    warning,\n    error,\n    disabled,\n    width:\n      width === 'stretch' || fieldBlockContext?.composition\n        ? width\n        : undefined,\n    contentWidth: width !== false ? width : undefined,\n    ...pickSpacingProps(props),\n  }\n\n  return (\n    <FieldBlock {...fieldSectionProps}>\n      {multiline ? (\n        <Textarea {...sharedProps} {...textareaProps} />\n      ) : mask ? (\n        <InputMasked {...sharedProps} {...inputProps} mask={mask} />\n      ) : (\n        <Input {...sharedProps} {...inputProps} />\n      )}\n    </FieldBlock>\n  )\n}\n\nStringComponent._supportsSpacingProps = true\nexport default StringComponent\n","import React, { useCallback } from 'react'\nimport classnames from 'classnames'\n\nimport { Checkbox, ToggleButton } from '../../../../components'\nimport ButtonRow from '../../Form/ButtonRow'\nimport FieldBlock from '../../FieldBlock'\nimport { useFieldProps } from '../../hooks'\nimport { FieldProps } from '../../types'\nimport { pickSpacingProps } from '../../../../components/flex/utils'\nimport ToggleButtonGroupContext from '../../../../components/toggle-button/ToggleButtonGroupContext'\nimport useTranslation from '../../hooks/useTranslation'\n\nexport type ToggleProps = {\n  valueOn: unknown\n  valueOff: unknown\n  variant?: 'checkbox' | 'checkbox-button' | 'button' | 'buttons'\n  textOn?: string\n  textOff?: string\n}\n\nexport type Props = FieldProps<unknown> & ToggleProps\n\nfunction Toggle(props: Props) {\n  const translations = useTranslation().BooleanField\n\n  const preparedProps: Props = {\n    ...props,\n    errorMessages: props.errorMessages,\n  }\n\n  const {\n    id,\n    className,\n    valueOn,\n    valueOff,\n    layout,\n    variant,\n    disabled,\n    label,\n    labelDescription,\n    textOn,\n    textOff,\n    value,\n    info,\n    warning,\n    error,\n    hasError,\n    htmlAttributes,\n    handleChange,\n  } = useFieldProps(preparedProps)\n\n  const handleCheckboxChange = useCallback(\n    ({ checked }) => {\n      handleChange?.(checked ? valueOn : valueOff)\n    },\n    [handleChange, valueOn, valueOff]\n  )\n  const handleToggleChange = useCallback(\n    ({ value }) => {\n      handleChange?.(value === 'on' ? valueOn : valueOff)\n    },\n    [handleChange, valueOn, valueOff]\n  )\n\n  const cn = classnames('dnb-forms-field-toggle', className)\n\n  const fieldSectionPropsWithoutLabel = {\n    forId: id,\n    className: cn,\n    ...pickSpacingProps(props),\n    info,\n    warning,\n    error,\n    disabled,\n  }\n\n  const fieldSectionProps = {\n    ...fieldSectionPropsWithoutLabel,\n    layout,\n    label,\n    labelDescription,\n    disabled,\n  }\n\n  const isOn = value === valueOn\n  const isOff = value === valueOff\n\n  switch (variant) {\n    default:\n    case 'checkbox':\n      return (\n        <FieldBlock {...fieldSectionPropsWithoutLabel}>\n          <Checkbox\n            id={id}\n            className={cn}\n            label={\n              label ??\n              (isOn\n                ? textOn ?? translations.yes\n                : textOff ?? translations.no)\n            }\n            checked={isOn}\n            disabled={disabled}\n            status={hasError ? 'error' : undefined}\n            onChange={handleCheckboxChange}\n            {...htmlAttributes}\n          />\n        </FieldBlock>\n      )\n    case 'button':\n      return (\n        <FieldBlock {...fieldSectionProps}>\n          <ToggleButton\n            id={id}\n            text={\n              isOn\n                ? textOn ?? translations.yes\n                : textOff ?? translations.no\n            }\n            checked={isOn}\n            disabled={disabled}\n            status={hasError ? 'error' : undefined}\n            value={value ? 'true' : 'false'}\n            on_change={handleCheckboxChange}\n            {...htmlAttributes}\n          />\n        </FieldBlock>\n      )\n    case 'buttons':\n      return (\n        <FieldBlock {...fieldSectionProps} asFieldset>\n          <ButtonRow bottom=\"x-small\">\n            <ToggleButtonGroupContext.Provider\n              value={{\n                value: isOn ? 'on' : isOff ? 'off' : null, // use \"null\" to reset the value\n                onChange: handleToggleChange,\n                status: hasError ? 'error' : undefined,\n                disabled,\n              }}\n            >\n              <ToggleButton\n                text={textOn ?? translations.yes}\n                value=\"on\"\n                {...htmlAttributes}\n              />\n              <ToggleButton\n                text={textOff ?? translations.no}\n                value=\"off\"\n                {...htmlAttributes}\n              />\n            </ToggleButtonGroupContext.Provider>\n          </ButtonRow>\n        </FieldBlock>\n      )\n    case 'checkbox-button':\n      return (\n        <FieldBlock {...fieldSectionProps}>\n          <ToggleButton\n            id={id}\n            variant=\"checkbox\"\n            text={\n              isOn\n                ? textOn ?? translations.yes\n                : textOff ?? translations.no\n            }\n            checked={isOn}\n            disabled={disabled}\n            status={hasError ? 'error' : undefined}\n            value={value ? 'true' : 'false'}\n            on_change={handleCheckboxChange}\n            {...htmlAttributes}\n          />\n        </FieldBlock>\n      )\n  }\n}\n\nToggle._supportsSpacingProps = true\nexport default Toggle\n","import React from 'react'\nimport classnames from 'classnames'\nimport { Space } from '../../../../components'\nimport type { ComponentProps } from '../../types'\n\nexport type Props = ComponentProps & {\n  children?: React.ReactNode\n}\n\nfunction ButtonRow(props: Props) {\n  const { className, children, ...rest } = props\n  return (\n    <Space\n      className={classnames('dnb-forms-button-row', className)}\n      {...rest}\n    >\n      {children}\n    </Space>\n  )\n}\n\nButtonRow._supportsSpacingProps = true\nexport default ButtonRow\n","import React, { useCallback, useContext, useMemo, useRef } from 'react'\nimport pointer from 'json-pointer'\nimport SectionContext, { SectionContextState } from './SectionContext'\nimport FieldPropsProvider from '../FieldProps'\n\nimport type { Props as DataContextProps } from '../../DataContext/Provider'\nimport type { FieldSectionProps, Path, FieldProps } from '../../types'\n\nexport type OverwritePropsDefaults = {\n  [key: Path]: (FieldProps & FieldSectionProps) | OverwritePropsDefaults\n}\nexport type SectionProps<overwriteProps = OverwritePropsDefaults> = {\n  /**\n   * Path to the section.\n   * When defined, fields inside the section will get this path as a prefix of their own path.\n   */\n  path?: Path\n\n  /**\n   * Overwrite field props for the section.\n   */\n  overwriteProps?: overwriteProps | OverwritePropsDefaults\n\n  /**\n   * Provide your own translations. Use the same format as defined in the translation files\n   */\n  translations?: DataContextProps<unknown>['translations']\n\n  /**\n   * Makes all fields inside it required.\n   */\n  required?: boolean\n\n  /**\n   * Callback when fields in the section are changed.\n   */\n  onChange?: (data: unknown) => void\n\n  /**\n   * Only for internal use and undocumented for now.\n   * Prioritize error techniques for the section.\n   * Can be `fieldSchema`, `sectionSchema` or `contextSchema.\n   */\n  errorPrioritization?: SectionContextState['errorPrioritization']\n}\n\nexport type LocalProps = SectionProps & {\n  children: React.ReactNode\n}\n\nfunction SectionComponent(props: LocalProps) {\n  const {\n    path,\n    overwriteProps,\n    translations,\n    required,\n    onChange,\n    errorPrioritization = ['contextSchema'],\n    children,\n  } = props\n\n  if (path && !path.startsWith('/')) {\n    throw new Error(`path=\"${path}\" must start with a slash`)\n  }\n\n  const {\n    path: nestedPath,\n    handleChange: handleNestedChange,\n    props: nestedProps,\n  } = useContext(SectionContext) || {}\n\n  const dataRef = useRef<unknown>({})\n  const handleChange = useCallback(\n    (path: Path, value: unknown) => {\n      pointer.set(dataRef.current, path, value)\n      onChange?.(dataRef.current)\n      handleNestedChange?.(path, value)\n    },\n    [handleNestedChange, onChange]\n  )\n\n  const identifier = useMemo(() => {\n    return `${nestedPath && nestedPath !== '/' ? nestedPath : ''}${\n      path || ''\n    }`\n  }, [path, nestedPath])\n  const fieldProps = required ? { required: true } : undefined\n\n  return (\n    <SectionContext.Provider\n      value={{\n        path: identifier,\n        errorPrioritization,\n        handleChange,\n        props,\n      }}\n    >\n      <FieldPropsProvider\n        overwriteProps={{\n          ...overwriteProps,\n          ...(nestedProps?.overwriteProps?.[\n            path.substring(1)\n          ] as OverwritePropsDefaults),\n        }}\n        translations={translations}\n        {...fieldProps}\n      >\n        {children}\n      </FieldPropsProvider>\n    </SectionContext.Provider>\n  )\n}\n\nSectionComponent._supportsSpacingProps = 'children'\nexport default SectionComponent\n","import React, { useCallback, useContext } from 'react'\nimport classnames from 'classnames'\nimport type { ComponentProps } from '../../types'\nimport DataContext from '../../DataContext/Context'\nimport Button, { ButtonProps } from '../../../../components/button/Button'\nimport SubmitIndicator from '../SubmitIndicator'\nimport useTranslation from '../../hooks/useTranslation'\nimport { send } from '../../../../icons'\n\nexport type Props = {\n  /**\n   * Show the submit indicator\n   */\n  showIndicator?: boolean\n} & ComponentProps &\n  Omit<ButtonProps, 'variant'> &\n  Partial<React.HTMLAttributes<HTMLButtonElement | HTMLAnchorElement>> & {\n    variant?: 'send'\n  }\n\nfunction SubmitButton(props: Props) {\n  const translations = useTranslation().SubmitButton\n\n  const { variant, className, showIndicator, children, text, ...rest } =\n    props\n\n  const content =\n    text ||\n    children ||\n    (variant === 'send' ? translations.sendText : translations.text)\n\n  const { formState, handleSubmit, isInsideFormElement } =\n    useContext(DataContext) || {}\n\n  const onClickHandler = useCallback(() => {\n    if (!isInsideFormElement) {\n      handleSubmit?.()\n    }\n  }, [isInsideFormElement, handleSubmit])\n\n  return (\n    <Button\n      className={classnames('dnb-forms-submit-button', className)}\n      onClick={onClickHandler}\n      type=\"submit\"\n      icon={variant === 'send' ? send : null}\n      {...rest}\n    >\n      {content}\n\n      <SubmitIndicator\n        state={\n          showIndicator ? 'pending' : formState // will be enabled in a follow-up PR\n        }\n      />\n    </Button>\n  )\n}\n\nSubmitButton._supportsSpacingProps = true\nexport default SubmitButton\n","/**\n * ATTENTION: This file is auto generated by using \"prepareTemplates\".\n * Do not change the content!\n *\n */\n\n/**\n * Library Index height-animation to autogenerate all the components and extensions\n * Used by \"prepareHeightAnimations\"\n */\n\nimport HeightAnimation from './height-animation/HeightAnimation'\nexport * from './height-animation/HeightAnimation'\nexport default HeightAnimation\n","import React, { AriaAttributes, useCallback, useContext } from 'react'\nimport pointer from 'json-pointer'\nimport { warn } from '../../../../shared/helpers'\nimport useMountEffect from '../../../../shared/helpers/useMountEffect'\nimport HeightAnimation, {\n  HeightAnimationProps,\n} from '../../../../components/HeightAnimation'\nimport DataContext, { FilterData } from '../../DataContext/Context'\nimport SectionContext from '../Section/SectionContext'\nimport FieldProps from '../FieldProps'\nimport type { Path, UseFieldProps } from '../../types'\nimport type { DataAttributes } from '../../hooks/useFieldProps'\n\ntype VisibleWhen =\n  | {\n      path: string\n      hasValue: unknown\n    }\n  | {\n      path: string\n      withValue: (value: unknown) => boolean\n    }\n\nexport type Props = {\n  visible?: boolean\n  /** Given data context path must be defined to show children */\n  pathDefined?: string\n  /** Given data context path must be undefined to show children */\n  pathUndefined?: string\n  /** Given data context path must be truthy to show children */\n  pathTruthy?: string\n  /** Given data context path must be falsy to show children */\n  pathFalsy?: string\n  /** Given data context path must be true to show children */\n  pathTrue?: string\n  /** Given data context path must be false to show children */\n  pathFalse?: string\n  /** Provide a `path` and a `hasValue` property with the excepted value in order to show children. You can alternatively provide a `withValue` function that returns a boolean. The first parameter is the value of the path. */\n  visibleWhen?: VisibleWhen\n  /** Same as `visibleWhen`, but with inverted logic. */\n  visibleWhenNot?: VisibleWhen\n  /** Infer visibility calling given derivative function with the whole data set. Should return true/false for visibility.   */\n  inferData?: (data: unknown) => boolean\n  /** Filter data based on provided criteria. The first parameter is the path, the second is the value, and the third is the props, and the fourth is the internal. Return false to filter out the data. */\n  filterData?: FilterData\n  /** Animate the visibility change */\n  animate?: boolean\n  /** Keep the content in the DOM, even if it's not visible */\n  keepInDOM?: boolean\n  /** When visibility is hidden, and `keepInDOM` is true, pass these props to the children */\n  fieldPropsWhenHidden?: UseFieldProps & DataAttributes & AriaAttributes\n  element?: HeightAnimationProps['element']\n  children: React.ReactNode\n\n  /** @deprecated Use `visibleWhen` instead */\n  pathValue?: string\n  /** @deprecated Use `visibleWhen` instead */\n  whenValue?: unknown\n}\n\nfunction Visibility({\n  visible,\n  pathDefined,\n  pathUndefined,\n  pathTruthy,\n  pathFalsy,\n  pathTrue,\n  pathFalse,\n  pathValue,\n  whenValue,\n  visibleWhen,\n  visibleWhenNot,\n  inferData,\n  filterData,\n  animate,\n  keepInDOM,\n  fieldPropsWhenHidden,\n  children,\n  ...rest\n}: Props) {\n  const dataContext = useContext(DataContext)\n  const sectionContext = useContext(SectionContext)\n\n  const sectionPath = sectionContext?.path\n  const composePath = useCallback(\n    (path: Path) => {\n      return `${\n        sectionPath && sectionPath !== '/' ? sectionPath : ''\n      }${path}`\n    },\n    [sectionPath]\n  )\n\n  useMountEffect(() => {\n    if (fieldPropsWhenHidden && !keepInDOM) {\n      warn('Using \"fieldPropsWhenHidden\" requires \"keepInDOM\" to be true.')\n    }\n  })\n\n  const check = () => {\n    if (visible === false) {\n      return\n    }\n\n    const data =\n      (filterData &&\n        dataContext.filterDataHandler?.(dataContext.data, filterData)) ||\n      dataContext.data\n\n    if (visibleWhen || visibleWhenNot) {\n      if (visibleWhenNot) {\n        visibleWhen = visibleWhenNot\n      }\n      const hasPath = pointer.has(data, composePath(visibleWhen.path))\n      if (hasPath) {\n        const value = pointer.get(data, composePath(visibleWhen.path))\n\n        const withValue = visibleWhen?.['withValue']\n        const result =\n          (withValue && withValue?.(value) === false) ||\n          (Object.prototype.hasOwnProperty.call(visibleWhen, 'hasValue') &&\n            visibleWhen?.['hasValue'] !== value)\n\n        if (visibleWhenNot) {\n          if (!result) {\n            return\n          }\n        } else if (result) {\n          return\n        }\n      } else {\n        return\n      }\n    }\n\n    if (pathDefined && !pointer.has(data, composePath(pathDefined))) {\n      return\n    }\n    if (pathUndefined && pointer.has(data, composePath(pathUndefined))) {\n      return\n    }\n\n    const getValue = (path: Path) => {\n      if (pointer.has(data, path)) {\n        return pointer.get(data, path)\n      }\n    }\n\n    if (pathTrue && getValue(composePath(pathTrue)) !== true) {\n      return\n    }\n    if (pathFalse && getValue(composePath(pathFalse)) !== false) {\n      return\n    }\n    if (\n      pathTruthy &&\n      Boolean(getValue(composePath(pathTruthy))) === false\n    ) {\n      return\n    }\n    if (pathFalsy && Boolean(getValue(composePath(pathFalsy))) === true) {\n      return\n    }\n    if (inferData && !inferData(data)) {\n      return\n    }\n\n    // Deprecated can be removed in v11\n    if (pathValue && getValue(composePath(pathValue)) !== whenValue) {\n      return\n    }\n\n    return true\n  }\n\n  const open = Boolean(check())\n\n  if (animate) {\n    const props = !open ? fieldPropsWhenHidden : null\n\n    return (\n      <HeightAnimation\n        open={open}\n        keepInDOM={Boolean(keepInDOM)}\n        className=\"dnb-forms-visibility\"\n        {...rest}\n      >\n        <FieldProps {...props}>{children}</FieldProps>\n      </HeightAnimation>\n    )\n  }\n\n  if (keepInDOM) {\n    const props = !open ? fieldPropsWhenHidden : null\n    return (\n      <span className=\"dnb-forms-visibility\" hidden={!open}>\n        <FieldProps {...props}>{children}</FieldProps>\n      </span>\n    )\n  }\n\n  return <>{open ? children : null}</>\n}\n\nVisibility._supportsSpacingProps = 'children'\nexport default Visibility\n","import { useContext, useMemo } from 'react'\nimport {\n  DefaultErrorMessages,\n  CustomErrorMessagesWithPaths,\n} from '../types'\nimport Context from '../DataContext/Context'\n\n/**\n * Custom hook that retrieves error messages based on the provided path and error configurations.\n *\n * @param path - The path to the error messages in the configuration.\n * @param errorMessages - Custom error messages with paths.\n * @param defaultErrorMessages - Default error messages.\n * @returns An object containing the merged error messages.\n */\nexport default function useErrorMessage(\n  path: string,\n  errorMessages: DefaultErrorMessages | CustomErrorMessagesWithPaths,\n  defaultErrorMessages: Record<string, string>\n) {\n  const context = useContext(Context)\n\n  return useMemo(() => {\n    const fromContext = context?.contextErrorMessages\n    return {\n      ...defaultErrorMessages,\n      ...fromContext,\n      ...fromContext?.[path],\n      ...errorMessages,\n    }\n  }, [\n    context?.contextErrorMessages,\n    path,\n    defaultErrorMessages,\n    errorMessages,\n  ])\n}\n","/** This file is auto generated by convertSvgToJsx.ts */\n\nimport React from 'react'\nconst send = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width={16}\n    height={16}\n    fill=\"none\"\n    viewBox=\"0 0 16 16\"\n    {...props}\n  >\n    <path\n      stroke=\"#000\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      strokeWidth={1.5}\n      d=\"m7.225 10.26 3.241 4.326a1.035 1.035 0 0 0 1.846-.43l2.24-11.928a1.035 1.035 0 0 0-1.566-1.07l-11.5 7.188a1.035 1.035 0 0 0 .55 1.913h5.189Zm0 0H5.669v3.216a1.035 1.035 0 0 0 1.618.855l1.977-1.348-2.04-2.724Zm0 0 6.893-9.078\"\n    />\n  </svg>\n)\nexport default send\n","/**\n * Web InputMasked Context\n *\n */\n\nimport React from 'react'\n\nconst InputMaskedContext = React.createContext({})\n\nexport default InputMaskedContext\n","// The original can be found here: https://github.com/text-mask/text-mask/tree/master/addons\n// No license was given at the point of writing\n\nconst emptyString = ''\nconst minus = '-'\nconst minusRegExp = /-/\nconst nonDigitsRegExp = /\\D+/g\nconst number = 'number'\nconst caretTrap = '[]'\nconst digitRegExp = /\\d/\n\nfunction convertToMask(strNumber) {\n  return strNumber.split(emptyString).map((char) => {\n    if (digitRegExp.test(char)) {\n      char = digitRegExp\n    }\n    return char\n  })\n}\n\nexport default function createNumberMask({\n  prefix = emptyString,\n  suffix = emptyString,\n  includeThousandsSeparator = true,\n  thousandsSeparatorSymbol = ' ',\n  allowDecimal = false,\n  decimalSymbol = ',',\n  decimalLimit = 2,\n  integerLimit = false,\n  requireDecimal = false,\n  allowNegative = true,\n} = {}) {\n  // http://stackoverflow.com/a/10899795/604296\n  function addThousandsSeparator(n, thousandsSeparatorSymbol) {\n    return n.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandsSeparatorSymbol) // eslint-disable-line\n  }\n\n  const prefixLength = (prefix && prefix.length) || 0\n  const suffixLength = (suffix && suffix.length) || 0\n\n  function numberMask(rawValue = emptyString) {\n    const rawValueLength = rawValue.length\n\n    if (\n      rawValue === emptyString ||\n      (rawValue[0] === prefix[0] && rawValueLength === 1)\n    ) {\n      return prefix\n        .split(emptyString)\n        .concat([digitRegExp])\n        .concat(suffix.split(emptyString))\n    } else if (rawValue === decimalSymbol && allowDecimal) {\n      return prefix\n        .split(emptyString)\n        .concat(['0', decimalSymbol, digitRegExp])\n        .concat(suffix.split(emptyString))\n    }\n\n    const isNegative = rawValue[0] === minus && allowNegative\n    // If negative remove \"-\" sign\n    if (isNegative) {\n      rawValue = rawValue.toString().substr(1)\n    }\n\n    const indexOfLastDecimal = rawValue.lastIndexOf(decimalSymbol)\n    const hasDecimal = indexOfLastDecimal !== -1\n\n    let integer\n    let fraction\n    let mask\n\n    // remove the suffix\n    if (rawValue.slice(suffixLength * -1) === suffix) {\n      rawValue = rawValue.slice(0, suffixLength * -1)\n    }\n\n    if (hasDecimal && (allowDecimal || requireDecimal)) {\n      integer = rawValue.slice(\n        rawValue.slice(0, prefixLength) === prefix ? prefixLength : 0,\n        indexOfLastDecimal\n      )\n\n      fraction = rawValue.slice(indexOfLastDecimal + 1, rawValueLength)\n      fraction = convertToMask(\n        fraction.replace(nonDigitsRegExp, emptyString)\n      )\n    } else {\n      if (rawValue.slice(0, prefixLength) === prefix) {\n        integer = rawValue.slice(prefixLength)\n      } else {\n        integer = rawValue\n      }\n    }\n\n    integer = integer.replace(nonDigitsRegExp, emptyString)\n\n    if (typeof integerLimit === number) {\n      integer = integer.slice(0, integerLimit)\n    }\n\n    integer = includeThousandsSeparator\n      ? addThousandsSeparator(integer, thousandsSeparatorSymbol)\n      : integer\n\n    mask = convertToMask(integer)\n\n    if ((hasDecimal && allowDecimal) || requireDecimal === true) {\n      if (rawValue[indexOfLastDecimal - 1] !== decimalSymbol) {\n        mask.push(caretTrap)\n      }\n\n      mask.push(decimalSymbol, caretTrap)\n\n      if (fraction) {\n        if (typeof decimalLimit === number) {\n          fraction = fraction.slice(0, decimalLimit)\n        }\n\n        mask = mask.concat(fraction)\n      }\n\n      if (\n        requireDecimal === true &&\n        rawValue[indexOfLastDecimal - 1] === decimalSymbol\n      ) {\n        mask.push(digitRegExp)\n      }\n    }\n\n    if (prefixLength > 0) {\n      mask = prefix.split(emptyString).concat(mask)\n    }\n\n    if (isNegative) {\n      // If user is entering a negative number, add a mask placeholder spot to attract the caret to it.\n      if (mask.length === prefixLength) {\n        mask.push(digitRegExp)\n      }\n\n      mask = [minusRegExp].concat(mask)\n    }\n\n    if (suffix.length > 0) {\n      mask = mask.concat(suffix.split(emptyString))\n    }\n\n    return mask\n  }\n\n  numberMask.instanceOf = 'createNumberMask'\n\n  return numberMask\n}\n","/**\n * Web InputMasked Component\n *\n */\n\nimport {\n  format,\n  getDecimalSeparator,\n  getThousandsSeparator,\n} from '../number-format/NumberUtils'\nimport { warn } from '../../shared/component-helper'\nimport { IS_IOS } from '../../shared/helpers'\nimport { safeSetSelection } from './text-mask/createTextMaskInputElement'\n\nconst enableLocaleSupportWhen = ['as_number', 'as_percent', 'as_currency']\nconst enableNumberMaskWhen = [\n  'as_number',\n  'as_percent',\n  'as_currency',\n  'number_mask',\n  'currency_mask',\n]\n\nexport const invisibleSpace = '\\u200B'\n\n/**\n * Will return true if a prop needs Locale support\n *\n * @param {object} props object with given component props\n * @returns boolean\n */\nexport const isRequestingLocaleSupport = (props) => {\n  return Object.entries(props).some(\n    ([k, v]) => v && enableLocaleSupportWhen.includes(k)\n  )\n}\n\n/**\n * Will return true if a prop will enable the internal NumberMask\n *\n * @param {object} props object with given component props\n * @returns boolean\n */\nexport const isRequestingNumberMask = (props) => {\n  return Object.entries(props).some(\n    ([k, v]) => v && enableNumberMaskWhen.includes(k)\n  )\n}\n\n/**\n * Probably the most complex part of this component\n * It will modify a given value based on certain criteria's\n *\n * @param {object} param0 object with properties\n * @property {string} localValue optional – if given, it will uses its ending to determine of what to return\n * @property {number|string} value component property value\n * @property {object} context Eufemia Context\n * @property {string} locale Eufemia locale (either from component or context)\n * @property {object} maskParams predefined mask parameters\n * @returns string Value\n */\nexport const correctNumberValue = ({\n  localValue = null,\n  props,\n  locale,\n  maskParams,\n}) => {\n  let value = props.value === null ? null : String(props.value)\n\n  if (isNaN(parseFloat(value))) {\n    return value\n  }\n\n  const decimalPos = value.indexOf('.')\n\n  if (\n    maskParams.integerLimit &&\n    typeof maskParams.integerLimit === 'number'\n  ) {\n    const limit = maskParams.integerLimit\n    const integers = value.split('.')[0]\n    const isNegative = parseFloat(integers) < 0\n    if (integers.length - (isNegative ? 1 : 0) > limit) {\n      const decimals = decimalPos > 0 ? value.slice(decimalPos) : ''\n      value = integers.slice(0, limit + (isNegative ? 1 : 0)) + decimals\n    }\n  }\n\n  const shouldHaveDecimals =\n    maskParams.allowDecimal ||\n    (maskParams.decimalLimit > 0 && maskParams.allowDecimal !== false)\n\n  if (!shouldHaveDecimals) {\n    if (decimalPos > -1) {\n      value = value.slice(0, decimalPos)\n    }\n  }\n\n  /**\n   * This only runs IF \"number_format\" is set – we do not use it else\n   */\n  if (props.number_format) {\n    const options = {\n      locale,\n      decimals: 0,\n      ...props.number_format,\n    }\n    if (shouldHaveDecimals) {\n      options.decimals = maskParams.decimalLimit\n    }\n    value = format(value, options)\n  }\n\n  const decimalSymbol = maskParams.decimalSymbol\n  value = value.replace('.', decimalSymbol)\n\n  if (localValue !== null) {\n    const localNumberValue = localValue.replace(/[^\\d,.-]/g, '')\n    const numberValue = value.replace(/[^\\d,.-]/g, '')\n    const valueHasDecimal = numberValue.includes(decimalSymbol)\n\n    if (!valueHasDecimal) {\n      const endsWithDecimal = localNumberValue.endsWith(decimalSymbol)\n      const endsWithZeroAndDecimal = localNumberValue.endsWith(\n        `${decimalSymbol}0`\n      )\n\n      if (endsWithDecimal) {\n        value = `${value}${decimalSymbol}`\n      } else if (\n        endsWithZeroAndDecimal &&\n        !numberValue.endsWith(`${decimalSymbol}0`)\n      ) {\n        /**\n         * When the users has 20,02, then hits \"backspace\",\n         * the returned {numberValue} in the onChange event would then be \"20\",\n         * but we want it to be 20,0\n         */\n        value = `${value}${decimalSymbol}0`\n      }\n    }\n\n    /**\n     * If the user removes a leading digit and we have left a leading zero.\n     *\n     * The users enters these steps:\n     * Step 1. 1012\n     * Step 2. 012 -> user removes 1, now use \"localValue\"\n     * Step 3. 2012\n     *\n     * If a dev listens on_change and sends the number value back in,\n     * for this, we also ensure that \"numberValue\" and \"localNumberValue\" is the same.\n     */\n    if (\n      localNumberValue !== '0' &&\n      localNumberValue.startsWith('0') &&\n      parseFloat(numberValue.replace(decimalSymbol, '.')) ===\n        parseFloat(localNumberValue.replace(decimalSymbol, '.'))\n    ) {\n      value = localValue\n    }\n\n    /**\n     * While typing;\n     * If the local value is - or -0 we use it.\n     * Also, because of invisible whitespace we remove everything else\n     */\n    if (/^(-|-0)$/.test(localValue.replace(/[^\\d-0]/g, ''))) {\n      value = localValue\n    } else if (localNumberValue === '' && numberValue === '0') {\n      value = ''\n    }\n  }\n\n  return value\n}\n\n/**\n * This is a helper for setting the cursor position,\n * when it is on a not allowed position\n *\n * @param {Element} element Input Element\n * @param {Object} maskParams Mask parameters, containing eventually suffix or prefix\n */\nexport const correctCaretPosition = (element, maskParams, props) => {\n  const correction = () => {\n    try {\n      const suffix = maskParams?.suffix\n      const prefix = maskParams?.prefix\n\n      const start = element.selectionStart\n      const end = element.selectionEnd\n\n      if (start !== end) {\n        return // stop here\n      }\n\n      if (suffix || prefix) {\n        const suffixStart = element.value.indexOf(suffix)\n        const suffixEnd = suffixStart + suffix?.length\n        let pos = undefined\n\n        if (start >= suffixStart && start <= suffixEnd) {\n          pos = suffixStart\n\n          // If there is a placeholder,\n          // and the user clicks after the suffix\n          // we want the position to be \"before\" the placeholderChar\n          if (\n            maskParams.placeholderChar !== invisibleSpace &&\n            element.value.length - 1 === String(suffix + prefix).length\n          ) {\n            pos = pos - 1\n          }\n        } else {\n          const prefixStart = element.value.indexOf(prefix)\n          const prefixEnd = prefixStart + prefix?.length || 0\n\n          if (start >= prefixStart && start <= prefixEnd) {\n            pos = prefixEnd\n          }\n        }\n\n        const char = element.value.slice(pos - 1, pos)\n        if (char === invisibleSpace) {\n          pos = suffixStart - 1\n        }\n\n        if (!isNaN(parseFloat(pos))) {\n          safeSetSelection(element, pos)\n        }\n      } else if (props?.mask && element.value.length === end) {\n        const chars = element.value.split('')\n\n        for (let l = chars.length, i = l - 1; i >= 0; i--) {\n          const char = chars[i]\n          const mask = props.mask[i]\n          if (\n            char &&\n            char !== invisibleSpace &&\n            mask instanceof RegExp &&\n            mask.test(char)\n          ) {\n            for (let n = i + 1; n < l; n++) {\n              const mask = props.mask[n]\n              if (mask?.test?.(char)) {\n                safeSetSelection(element, n)\n                break\n              }\n            }\n\n            break\n          }\n        }\n      }\n    } catch (e) {\n      warn(e)\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    window.requestAnimationFrame(correction)\n  }\n}\n\n/**\n * Manipulate needed mask for handle: percent\n *\n * @param {object} param0 object with properties\n * @property {object} props Component property\n * @property {string} locale Eufemia locale (either from component or context)\n * @property {object} maskParams predefined mask parameters\n * @returns object maskParams\n */\nexport const handlePercentMask = ({ props, locale, maskParams }) => {\n  const value = format(props.value, { locale, percent: true })\n  maskParams.suffix = String(value)?.match(/((\\s|)%)$/g, '$1')?.[0] || ' %'\n\n  return maskParams\n}\n\n/**\n * Return needed mask for handle: currency\n *\n * @param {object} param0 object with properties\n * @property {object} context Eufemia context\n * @property {object} mask_options Component property for change the mask parameters\n * @property {object} currency_mask Component property for change the currency parameters\n * @returns object maskParams\n */\nexport const handleCurrencyMask = ({ mask_options, currency_mask }) => {\n  const maskParams = {\n    showMask: true,\n    placeholderChar: null,\n    allowDecimal: true,\n    decimalLimit: 2,\n    decimalSymbol: ',',\n    ...mask_options,\n    ...currency_mask,\n  }\n\n  const fix =\n    typeof currency_mask === 'string'\n      ? currency_mask\n      : typeof maskParams.currency === 'string'\n      ? maskParams.currency\n      : 'kr'\n\n  maskParams.suffix = ` ${fix}`\n\n  return maskParams\n}\n\n/**\n * Return needed mask for handle: number\n *\n * @param {object} param0 object with properties\n * @property {object} context Eufemia context\n * @property {object} mask_options Component property for change the mask parameters\n * @property {object} number_mask Component property for change the number parameters\n * @returns object maskParams\n */\nexport const handleNumberMask = ({ mask_options, number_mask }) => {\n  const maskParams = {\n    decimalSymbol: ',',\n    ...mask_options,\n    ...number_mask,\n  }\n\n  if (typeof maskParams.allowDecimal === 'undefined') {\n    maskParams.allowDecimal = maskParams.decimalLimit > 0\n  }\n\n  return maskParams\n}\n\n/**\n * Returns the type of what inputMode or type attribute should be used\n *\n * @param {function} mask mask function\n * @returns undefined|decimal|numeric\n */\nexport function getSoftKeyboardAttributes(mask) {\n  if (mask?.instanceOf !== 'createNumberMask') {\n    return undefined\n  }\n\n  const maskParams = mask?.maskParams\n\n  // because of the missing minus key, we still have to use text on iOS\n  if (IS_IOS && maskParams?.allowNegative !== false) {\n    return undefined\n  }\n\n  return {\n    inputMode:\n      maskParams.allowDecimal && maskParams.decimalLimit !== 0\n        ? 'decimal'\n        : 'numeric',\n  }\n}\n\n/**\n * Returns the thousands separator character\n *\n * @param {string} locale Component or context locale\n * @returns string\n */\nexport function handleThousandsSeparator(locale) {\n  return getThousandsSeparator(locale).replace(' ', ' ') // replace non-breaking space with a regular space\n}\n\n/**\n * Returns the decimal separator character\n *\n * @param {string} locale Component or context locale\n * @returns string\n */\nexport function handleDecimalSeparator(locale) {\n  let decimalSymbol = getDecimalSeparator(locale)\n\n  return decimalSymbol\n}\n\n/**\n * Will take a JSON and return it parsed\n *\n * @param {string} str\n * @param {*} fallback optional fallback\n * @returns parsed json\n */\nexport function fromJSON(str, fallback = null) {\n  if (typeof str === 'string' && str[0] === '{') {\n    return JSON.parse(str)\n  }\n\n  return str || fallback\n}\n","/**\n * Web InputMasked Component\n *\n */\n\nimport React from 'react'\nimport classnames from 'classnames'\nimport {\n  cleanNumber,\n  getCurrencySymbol,\n} from '../number-format/NumberUtils'\nimport {\n  isTrue,\n  dispatchCustomElementEvent,\n  extendPropsWithContext,\n} from '../../shared/component-helper'\nimport { safeSetSelection } from './text-mask/createTextMaskInputElement'\n\nimport TextMask from './TextMask'\nimport createNumberMask from './addons/createNumberMask'\nimport keycode from 'keycode'\nimport InputMaskedContext from './InputMaskedContext'\n\nimport {\n  isRequestingLocaleSupport,\n  isRequestingNumberMask,\n  correctNumberValue,\n  handlePercentMask,\n  handleCurrencyMask,\n  handleNumberMask,\n  correctCaretPosition,\n  getSoftKeyboardAttributes,\n  handleThousandsSeparator,\n  handleDecimalSeparator,\n  fromJSON,\n  invisibleSpace,\n} from './InputMaskedUtils'\n\n// SSR warning fix: https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nconst useLayoutEffect =\n  typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect\n\n/**\n * Takes all component properties and filters out all internal used properties\n *\n * @returns object {props, htmlAttributes}\n */\nexport const useFilteredProps = () => {\n  const { props } = React.useContext(InputMaskedContext)\n\n  const {\n    mask, // eslint-disable-line\n    number_mask, // eslint-disable-line\n    currency_mask, // eslint-disable-line\n    number_format, // eslint-disable-line\n    mask_options, // eslint-disable-line\n    as_currency, // eslint-disable-line\n    as_number, // eslint-disable-line\n    as_percent, // eslint-disable-line\n    locale, // eslint-disable-line\n    show_mask, // eslint-disable-line\n    show_guide, // eslint-disable-line\n    pipe, // eslint-disable-line\n    keep_char_positions, // eslint-disable-line\n    placeholder_char, // eslint-disable-line\n\n    // Get get rest of possible attributes\n    ...attributes\n  } = props\n\n  return { props, htmlAttributes: Object.freeze(attributes) }\n}\n\n/**\n * Returns locale from either component or context\n *\n * @returns string\n */\nexport const useTranslation = () => {\n  const { props, context } = React.useContext(InputMaskedContext)\n\n  let { locale } = props\n  if (!locale && context?.locale) {\n    locale = context.locale\n  }\n\n  return locale\n}\n\n/**\n * Handle internal value state\n *\n * It handles both the value state given as a prop form outside,\n * along with the current written and internal value.\n *\n * @returns object with internal value state and state setter\n */\nexport const useLocalValue = () => {\n  const { props, context } = React.useContext(InputMaskedContext)\n  const maskParams = useNumberMaskParams() || {}\n  const locale = useTranslation()\n\n  const [localValue, setLocalValue] = React.useState(() =>\n    correctNumberValue({\n      locale,\n      props,\n      maskParams,\n    })\n  )\n\n  /**\n   * Use an effect here, just;\n   * because when a property gets changed from outside\n   */\n  React.useEffect(() => {\n    const value = correctNumberValue({\n      localValue,\n      locale,\n      props,\n      maskParams,\n    })\n\n    setLocalValue(value)\n\n    // Do not set \"localValue\" and \"maskParams\" here\n  }, [props, context, locale]) // eslint-disable-line\n\n  return { localValue, setLocalValue }\n}\n\n/**\n * Create createNumberMask if number mask parameters exists\n *\n * @returns mask function\n */\nexport const useNumberMask = () => {\n  const maskParams = useNumberMaskParams()\n  const { props } = React.useContext(InputMaskedContext)\n\n  if (!maskParams || !isRequestingNumberMask(props)) {\n    return null\n  }\n\n  const mask = createNumberMask(maskParams)\n\n  mask.maskParams = maskParams\n\n  return mask\n}\n\n/**\n * Returns either internal mask or given property mask\n *\n * @returns mask function\n */\nexport const useMask = () => {\n  const { props } = React.useContext(InputMaskedContext)\n\n  const numberMask = useNumberMask()\n  if (numberMask) {\n    return numberMask\n  }\n\n  return props.mask\n}\n\n/**\n * Returns the final mask params\n *\n * @returns mask params\n */\nexport const useMaskParams = () => {\n  const { props } = React.useContext(InputMaskedContext)\n\n  const {\n    keep_char_positions,\n    show_guide,\n    show_mask,\n    placeholder_char,\n    placeholder,\n  } = props\n\n  const mask = useMask()\n  const maskParams = useNumberMaskParams() || {}\n\n  maskParams.showMask = !placeholder && isTrue(show_mask)\n\n  // Revalidated placeholder char to a zero width space\n  maskParams.placeholderChar = placeholder_char\n  if (typeof mask?.placeholderChar !== 'undefined') {\n    maskParams.placeholderChar = mask.placeholderChar\n  }\n  if (maskParams.placeholderChar === null) {\n    maskParams.placeholderChar = invisibleSpace\n  }\n\n  if (typeof mask?.showMask !== 'undefined') {\n    maskParams.showMask = mask.showMask\n  }\n\n  maskParams.showGuide = isTrue(show_guide)\n  maskParams.keepCharPositions = isTrue(keep_char_positions)\n\n  return maskParams\n}\n\n/**\n * Handle the TextMask dependency\n *\n * @returns React Element\n */\nexport const useInputElement = () => {\n  const { props } = React.useContext(InputMaskedContext)\n  const { pipe, inner_ref } = props\n\n  const mask = useMask()\n  const { showMask, showGuide, placeholderChar, keepCharPositions } =\n    useMaskParams()\n\n  const isFn = typeof inner_ref === 'function'\n  const refHook = React.useRef()\n  const ref = (!isFn && inner_ref) || refHook\n\n  useLayoutEffect(() => {\n    if (isFn) {\n      inner_ref?.(ref.current)\n    }\n  }, [inner_ref, isFn, ref])\n\n  // Create the actual input element\n  const inputElementRef = React.useRef(<input ref={ref} />)\n\n  const InputElement = (params, innerRef) => {\n    // Set ref for Eufemia input\n    innerRef.current = ref.current\n\n    return (\n      <TextMask\n        inputRef={ref}\n        inputElement={inputElementRef.current}\n        pipe={pipe}\n        mask={mask || []}\n        showMask={showMask}\n        guide={showGuide}\n        keepCharPositions={keepCharPositions}\n        placeholderChar={placeholderChar}\n        {...getSoftKeyboardAttributes(mask)}\n        {...params}\n        className={classnames(\n          params.className,\n          showMask &&\n            showGuide &&\n            placeholderChar &&\n            placeholderChar !== invisibleSpace &&\n            'dnb-input-masked--guide' // will use --font-family-monospace\n        )}\n      />\n    )\n  }\n  return InputElement\n}\n\n/**\n * Will map some events we need to map during typing\n *\n * @param {object} param0\n * @property {function} setLocalValue setState handler\n * @returns object of events to handle\n */\nexport const useEventMapping = ({ setLocalValue }) => {\n  const callEvent = useCallEvent({ setLocalValue })\n\n  return {\n    onBeforeInput: (event) => callEvent({ event }, 'on_before_input'),\n    onFocus: (params) => callEvent(params, 'on_focus'),\n    onBlur: (params) => callEvent(params, 'on_blur'),\n    onMouseUp: (event) => callEvent({ event }, 'on_mouse_up'),\n    onMouseDown: (event) => callEvent({ event }, 'on_mouse_down'),\n    onKeyDown: (params) => callEvent(params, 'on_key_down'),\n    onSubmit: (params) => callEvent(params, 'on_submit'),\n    onChange: (params) => callEvent(params, 'on_change'),\n\n    on_focus: undefined,\n    on_blur: undefined,\n    on_key_down: undefined,\n    on_submit: undefined,\n    on_change: undefined,\n  }\n}\n\n/**\n * Will map some events we need to map during typing\n *\n * @param {object} param0\n * @property {function} setLocalValue setState handler\n * @returns event handler function\n */\nconst useCallEvent = ({ setLocalValue }) => {\n  const { props } = React.useContext(InputMaskedContext)\n  const maskParams = useMaskParams()\n  const isNumberMask = useNumberMask()\n\n  // Source: https://en.wikipedia.org/wiki/Decimal_separator\n  const decimalSeparators = /[,.'·]/\n  let isUnidentified = false\n\n  const callEvent = ({ event, value }, name) => {\n    value = value || event.target.value\n    const selStart = event.target.selectionStart\n    let keyCode = keycode(event)\n\n    // Android issue: https://bugs.chromium.org/p/chromium/issues/detail?id=118639\n    if (\n      name === 'on_key_down' &&\n      (event.which === 229 || keyCode === undefined)\n    ) {\n      isUnidentified = true\n    }\n\n    // Android issue: https://bugs.chromium.org/p/chromium/issues/detail?id=118639\n    // so we use this solution instead\n    if (\n      isUnidentified &&\n      name === 'on_before_input' &&\n      typeof event?.data !== 'undefined'\n    ) {\n      name = 'on_key_down'\n      keyCode = event.data\n      isUnidentified = false\n    }\n\n    // Prevent entering a leading zero\n    if (\n      name === 'on_key_down' &&\n      !isUnidentified &&\n      maskParams?.disallowLeadingZeroes &&\n      (keyCode === '0' ||\n        keyCode === 'numpad 0' ||\n        (value.replace(/[^\\d]/g, '') === '' &&\n          decimalSeparators.test(keyCode)))\n    ) {\n      const testValue = (\n        value.slice(0, selStart) +\n        '0' +\n        value.slice(selStart + 1, value.length)\n      ).replace(/[^\\d]/g, '')\n\n      if (/^0/.test(testValue)) {\n        event.preventDefault()\n      }\n    }\n\n    if (\n      name === 'on_key_down' &&\n      isNumberMask &&\n      !isUnidentified &&\n      maskParams?.decimalSymbol\n    ) {\n      const hasDecimalSymbol = value.includes(maskParams.decimalSymbol)\n      const allowedDecimals =\n        maskParams.decimalLimit > 0 || maskParams.allowDecimal !== false\n\n      if (!allowedDecimals && decimalSeparators.test(keyCode)) {\n        event.preventDefault()\n      }\n\n      const charAtSelection = value.slice(selStart, selStart + 1)\n\n      if (allowedDecimals) {\n        // if we have already a decimal ...\n        if (hasDecimalSymbol && decimalSeparators.test(keyCode)) {\n          // ... we set the cursor on after the decimalSeparators\n          if (decimalSeparators.test(charAtSelection)) {\n            const index = value.indexOf(maskParams.decimalSymbol)\n            if (index > -1) {\n              safeSetSelection(event.target, index + 1)\n            }\n          }\n\n          // ... we do not allow to type another\n          event.preventDefault()\n        }\n\n        // replace other decimal\n        else if (\n          !hasDecimalSymbol &&\n          keyCode !== maskParams.decimalSymbol &&\n          decimalSeparators.test(keyCode)\n        ) {\n          value = value.slice(0, selStart)\n          setLocalValue(value + maskParams.decimalSymbol)\n          event.target.value = value + maskParams.decimalSymbol\n          event.preventDefault()\n        }\n      }\n\n      // move cursor to right if key is delete and char at selection is thousand separator\n      if (\n        keyCode === 'delete' &&\n        charAtSelection === (maskParams.thousandsSeparatorSymbol || ' ')\n      ) {\n        safeSetSelection(event.target, selStart + 1)\n        event.preventDefault()\n      }\n    }\n\n    let num = cleanNumber(value, {\n      prefix: maskParams.prefix,\n      suffix: maskParams.suffix,\n      decimalSeparator: maskParams.decimalSymbol || ',',\n      thousandsSeparator: maskParams.thousandsSeparatorSymbol || ' ',\n    })\n\n    // We don't want to return NaN, so we set it to 0\n    if (num === '-') {\n      num = -0\n    }\n\n    const numberValue = Number(num)\n\n    // Return '' (empty string) when the user has entered something invalid\n    const cleanedValue =\n      numberValue === 0 && String(num).charAt(0) !== '0' ? '' : num\n\n    switch (name) {\n      case 'on_focus':\n      case 'on_key_down':\n      case 'on_mouse_down':\n      case 'on_mouse_up':\n        event.target.runCorrectCaretPosition = () =>\n          correctCaretPosition(event.target, maskParams, props)\n        if (!event.target.__getCorrectCaretPosition) {\n          event.target.runCorrectCaretPosition()\n        }\n        break\n    }\n\n    const result = dispatchCustomElementEvent(props, name, {\n      event,\n      value,\n      numberValue,\n      cleanedValue,\n    })\n\n    if (name === 'on_change') {\n      setLocalValue(value)\n    }\n\n    return result\n  }\n\n  return callEvent\n}\n\n/**\n * Returns number mask parameters if requested by the component properties\n *\n * @returns object of number mask parameter\n */\nconst useNumberMaskParams = () => {\n  const { props } = React.useContext(InputMaskedContext)\n  const locale = useTranslation()\n\n  if (!isRequestingNumberMask(props)) {\n    return { ...fromJSON(props.mask_options) }\n  }\n\n  let { number_mask, currency_mask, mask_options } = props\n  const { as_number, as_percent, as_currency, value } = props\n\n  mask_options = fromJSON(mask_options)\n  number_mask = isTrue(number_mask) ? {} : fromJSON(number_mask)\n  currency_mask = isTrue(currency_mask)\n    ? {}\n    : fromJSON(currency_mask, {\n        currency: currency_mask,\n      })\n  if (!currency_mask?.currency) {\n    delete currency_mask.currency\n  }\n\n  if (isRequestingLocaleSupport(props)) {\n    const thousandsSeparatorSymbol = handleThousandsSeparator(locale)\n    const decimalSymbol = handleDecimalSeparator(locale)\n\n    if (isTrue(as_number) || isTrue(as_percent)) {\n      number_mask = extendPropsWithContext(number_mask, null, {\n        decimalSymbol,\n        thousandsSeparatorSymbol,\n      })\n    } else if (as_currency) {\n      currency_mask = extendPropsWithContext(currency_mask, null, {\n        decimalSymbol,\n        thousandsSeparatorSymbol,\n        currency: getCurrencySymbol(\n          locale,\n          typeof as_currency === 'string' ? as_currency : null,\n          currency_mask?.currencyDisplay,\n          value\n        ),\n      })\n    }\n  }\n\n  let maskParams = null\n\n  if (number_mask) {\n    maskParams = handleNumberMask({\n      mask_options,\n      number_mask,\n    })\n\n    if (isTrue(as_percent)) {\n      maskParams = handlePercentMask({ props, locale, maskParams })\n    }\n  } else if (currency_mask) {\n    maskParams = handleCurrencyMask({\n      mask_options,\n      currency_mask,\n    })\n  }\n\n  return maskParams\n}\n","/**\n * Web InputMasked Component\n *\n */\n\nimport React from 'react'\nimport Input from '../input/Input'\nimport classnames from 'classnames'\nimport {\n  useInputElement,\n  useEventMapping,\n  useFilteredProps,\n  useLocalValue,\n} from './InputMaskedHooks'\n\nexport default function InputMaskedElement() {\n  const inputElement = useInputElement()\n  const { localValue, setLocalValue } = useLocalValue()\n  const events = useEventMapping({ setLocalValue })\n\n  const { props, htmlAttributes } = useFilteredProps()\n  const {\n    className, // eslint-disable-line\n  } = props\n\n  return (\n    <Input\n      {...htmlAttributes}\n      {...events}\n      input_element={inputElement}\n      value={localValue}\n      className={classnames('dnb-input-masked', className)}\n    />\n  )\n}\n","/* eslint-disable react/no-unused-prop-types */\n/**\n * Web InputMasked Component\n *\n * This is a legacy component.\n * For refferencing while developing new features, please use a Functional component.\n */\n\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { extendPropsWithContext } from '../../shared/component-helper'\nimport InputMaskedContext from './InputMaskedContext'\nimport InputMaskedElement from './InputMaskedElement'\nimport Input, { inputPropTypes } from '../input/Input'\nimport Context from '../../shared/Context'\n\nconst InputMasked = (props) => {\n  const context = React.useContext(Context)\n\n  // Remove masks defined in Provider/Context, because it overwrites a custom mask\n  if (props?.mask) {\n    const alias = context?.InputMasked\n    for (const key in alias) {\n      if (/^as[_A-Z]|number_mask|currency_mask/.test(key)) {\n        delete alias[key]\n      }\n    }\n  }\n\n  const contextAndProps = React.useMemo(() => {\n    return extendPropsWithContext(\n      props,\n      InputMasked.defaultProps,\n      context?.InputMasked\n    )\n  }, [context?.InputMasked, props])\n\n  return (\n    <InputMaskedContext.Provider\n      value={{\n        props: contextAndProps,\n        context,\n      }}\n    >\n      <InputMaskedElement />\n    </InputMaskedContext.Provider>\n  )\n}\n\nInputMasked.propTypes = {\n  mask: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.array,\n    PropTypes.func,\n  ]),\n  number_mask: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.bool,\n    PropTypes.object,\n  ]),\n  currency_mask: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.bool,\n    PropTypes.object,\n  ]),\n  mask_options: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  number_format: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  locale: PropTypes.string,\n  as_currency: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  as_number: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  as_percent: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  show_mask: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  show_guide: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  pipe: PropTypes.func,\n  keep_char_positions: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.bool,\n  ]),\n  placeholder_char: PropTypes.string,\n  inner_ref: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n\n  on_change: PropTypes.func,\n  on_submit: PropTypes.func,\n  on_focus: PropTypes.func,\n  on_blur: PropTypes.func,\n  on_submit_focus: PropTypes.func,\n  on_submit_blur: PropTypes.func,\n\n  ...inputPropTypes,\n}\n\nInputMasked.defaultProps = {\n  ...Input.defaultProps,\n\n  mask: null,\n  number_mask: null,\n  currency_mask: null,\n  mask_options: null,\n  number_format: null,\n  as_currency: null,\n  as_number: null,\n  as_percent: null,\n  locale: null,\n  show_mask: false,\n  show_guide: true,\n  pipe: null,\n  keep_char_positions: false,\n  placeholder_char: null,\n  inner_ref: null,\n\n  on_change: null,\n  on_submit: null,\n  on_focus: null,\n  on_blur: null,\n  on_submit_focus: null,\n  on_submit_blur: null,\n}\n\nInputMasked._formElement = true\nInputMasked._supportsSpacingProps = true\n\nexport default InputMasked\n","import { IS_IOS } from '../../../shared/helpers'\n\n/**\n * This is a helper function (hack),\n * that will evoke a good numeric keyboard (on iOS) that supports decimals and minus keys.\n */\nexport default class InputModeNumber {\n  inputElement: HTMLInputElement\n  labelElement: HTMLLabelElement\n  timeout: NodeJS.Timer\n  hasFocus: boolean\n  focusEventName: string\n  blurEventName: string\n\n  setElement(element: HTMLInputElement) {\n    if (!IS_IOS) {\n      return // stop here\n    }\n\n    /**\n     * Why use \"mouseenter\" and not \"focus\", \"mousedown\" or \"touchstart\"?\n     * - Because \"touchstart\" has unexpected behavior when holding the finger down before releasing.\n     * - And because \"focus\" and \"mousedown\" is too late, we then can't change the type anymore.\n     */\n    this.focusEventName = 'mouseenter'\n    this.blurEventName = 'blur'\n\n    if (!this.inputElement) {\n      this.inputElement = element\n      this.add()\n      this.handleLabel()\n    }\n  }\n  handleLabel() {\n    const id = this.inputElement?.id\n    if (!id) {\n      return\n    }\n\n    this.labelElement = document.querySelector(\n      `[for=\"${id}\"]`\n    ) as HTMLLabelElement\n\n    if (this.labelElement) {\n      this.labelElement.addEventListener('mousedown', this.onFocus)\n    }\n  }\n  add() {\n    const fnId = '__getCorrectCaretPosition'\n    if (this.inputElement && !this.inputElement?.[fnId]) {\n      this.inputElement[fnId] = true\n\n      this.inputElement.addEventListener(this.focusEventName, this.onFocus)\n      this.inputElement.addEventListener(this.blurEventName, this.onBlur)\n    }\n  }\n  removeEvent(element: HTMLInputElement | HTMLLabelElement) {\n    if (element) {\n      element.removeEventListener(this.focusEventName, this.onFocus)\n      element.removeEventListener(this.blurEventName, this.onBlur)\n      element.removeEventListener('mousedown', this.onFocus)\n    }\n  }\n  remove() {\n    clearTimeout(this.timeout)\n\n    this.removeEvent(this.inputElement)\n    this.removeEvent(this.labelElement)\n\n    delete this.inputElement\n    delete this.labelElement\n  }\n  onBlur = () => {\n    this.hasFocus = false\n  }\n  onFocus = () => {\n    if (this.hasFocus || !this.inputElement) {\n      return\n    }\n\n    this.hasFocus = true\n\n    const type = this.inputElement.type\n\n    if (type === 'number') {\n      return // stop here\n    }\n\n    const value = this.inputElement.value\n    const placeholder = this.inputElement.placeholder\n\n    // To prevent flickering, show the placeholder, while the input value is \"empty\".\n    this.inputElement.placeholder = value\n\n    // Changing the type, will remove the current input value to show as \"empty\".\n    this.inputElement.type = 'number'\n\n    // Reset the input again\n    clearTimeout(this.timeout)\n    this.timeout = setTimeout(() => {\n      this.inputElement.type = type\n      this.inputElement.value = value // set the input value\n      this.inputElement.placeholder = placeholder\n      this.inputElement['runCorrectCaretPosition']?.()\n    }, 5)\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport createTextMaskInputElement from './text-mask/createTextMaskInputElement'\nimport InputModeNumber from './text-mask/InputModeNumber'\nimport { isNil } from './text-mask/utilities'\n\nexport default class TextMask extends React.PureComponent {\n  static propTypes = {\n    mask: PropTypes.oneOfType([\n      PropTypes.array,\n      PropTypes.func,\n      PropTypes.bool,\n      PropTypes.shape({\n        mask: PropTypes.oneOfType([PropTypes.array, PropTypes.func]),\n        pipe: PropTypes.func,\n      }),\n    ]).isRequired,\n    inputRef: PropTypes.object,\n    inputElement: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n    onChange: PropTypes.func,\n    guide: PropTypes.bool,\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    pipe: PropTypes.func,\n    placeholderChar: PropTypes.string,\n    keepCharPositions: PropTypes.bool,\n    showMask: PropTypes.bool,\n  }\n\n  static defaultProps = {\n    inputElement: null,\n    inputRef: null,\n    onChange: null,\n    guide: null,\n    value: null,\n    pipe: null,\n    placeholderChar: null,\n    keepCharPositions: null,\n    showMask: null,\n  }\n\n  constructor(props) {\n    super(props)\n\n    this.inputRef = props.inputRef || React.createRef()\n  }\n\n  componentDidMount() {\n    this.initTextMask()\n  }\n\n  componentWillUnmount() {\n    this.inputMode?.remove()\n  }\n\n  initTextMask() {\n    const {\n      props,\n      props: { value, inputMode },\n    } = this\n\n    const inputElement = this.inputRef.current\n    this.textMaskInputElement = createTextMaskInputElement({\n      ...props,\n      inputElement,\n    })\n    this.textMaskInputElement.update(value)\n\n    if (!inputMode && inputMode !== 'none') {\n      this.inputMode = new InputModeNumber()\n    }\n\n    this.inputMode?.setElement(inputElement)\n  }\n\n  onChange = (event) => {\n    this.textMaskInputElement.update()\n\n    if (typeof this.props.onChange === 'function') {\n      return this.props.onChange(event)\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // Getting props affecting value\n    const { value, pipe, mask, guide, placeholderChar, showMask } =\n      this.props\n\n    // Сalculate that settings was changed:\n    // - `pipe` converting to string, to compare function content\n    // - `mask` converting to string, to compare values or function content\n    // - `keepCharPositions` excludes, because it affect only cursor position\n    const settings = { guide, placeholderChar, showMask }\n    const isPipeChanged =\n      typeof pipe === 'function' && typeof prevProps.pipe === 'function'\n        ? pipe.toString() !== prevProps.pipe.toString()\n        : (isNil(pipe) && !isNil(prevProps.pipe)) ||\n          (!isNil(pipe) && isNil(prevProps.pipe))\n    const isMaskChanged = mask.toString() !== prevProps.mask.toString()\n    const isSettingChanged =\n      Object.keys(settings).some(\n        (prop) => settings[prop] !== prevProps[prop]\n      ) ||\n      isMaskChanged ||\n      isPipeChanged\n\n    // Сalculate that value was changed\n    const isValueChanged =\n      value !== this.inputRef.current.value || prevProps.value !== value\n\n    // Check value and settings to prevent duplicating update() call\n    if (isValueChanged || isSettingChanged) {\n      this.initTextMask()\n    }\n  }\n\n  render() {\n    const {\n      inputElement,\n      inputRef, // eslint-disable-line\n      mask, // eslint-disable-line\n      guide, // eslint-disable-line\n      pipe, // eslint-disable-line\n      placeholderChar, // eslint-disable-line\n      keepCharPositions, // eslint-disable-line\n      value, // eslint-disable-line\n      onChange, // eslint-disable-line\n      showMask, // eslint-disable-line\n\n      ...props\n    } = this.props\n\n    const params = {\n      onChange: this.onChange,\n      ...props,\n    }\n\n    return inputElement ? (\n      React.cloneElement(inputElement, params)\n    ) : (\n      <input ref={this.inputRef} {...params} />\n    )\n  }\n}\n","export const placeholderChar = '_'\nexport const strFunction = 'function'\n","const defaultArray = []\nconst emptyString = ''\n\nexport default function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray,\n}) {\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0\n  }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const conformedValueLength = conformedValue.length\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit =\n    editLength > 1 && !isAddition && !isFirstRawValue\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition\n  }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar =\n    isAddition &&\n    (previousConformedValue === conformedValue ||\n      conformedValue === placeholder)\n\n  let startingSearchIndex = 0\n  let trackRightCharacter\n  let targetChar\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase()\n    const normalizedRawValue = rawValue.toLowerCase()\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue\n      .substr(0, currentCaretPosition)\n      .split(emptyString)\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter(\n      (char) => normalizedConformedValue.indexOf(char) !== -1\n    )\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1]\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter((char) => char !== placeholderChar).length\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter((char) => char !== placeholderChar).length\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft =\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !==\n        placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] ===\n        placeholder[intersection.length - 2]\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true\n      targetChar = rawValue[currentCaretPosition]\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map(\n      (index) => normalizedConformedValue[index]\n    )\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter(\n      (char) => char === targetChar\n    ).length\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter(\n      (char) => char === targetChar\n    ).length\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter(\n        (char, index) =>\n          // Check if `char` is the same as our `targetChar`, so we account for it\n          char === targetChar &&\n          // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n          // index because if they are equal, that means we are already counting those characters in\n          // `countTargetCharInIntersection`\n          rawValue[index] !== char\n      ).length\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches =\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0)\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i]\n\n      startingSearchIndex = i + 1\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    }\n  }\n}\n","import {\n  convertMaskToPlaceholder,\n  isArray,\n  processCaretTraps,\n} from './utilities'\nimport {\n  placeholderChar as defaultPlaceholderChar,\n  strFunction,\n} from './constants'\n\nconst emptyArray = []\nconst emptyString = ''\n\nexport default function conformToMask(\n  rawValue = emptyString,\n  mask = emptyArray,\n  config = {}\n) {\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === strFunction) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config)\n\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      mask = processCaretTraps(mask).maskWithoutCaretTraps\n    } else {\n      throw new Error(\n        'Text-mask:conformToMask; The mask property must be an array.'\n      )\n    }\n  }\n\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions,\n  } = config\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide =\n    guide === false && previousConformedValue !== undefined\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const maskLength = mask.length\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange =\n    currentCaretPosition + (isAddition ? -editDistance : 0)\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance)\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue =\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength)\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n    char,\n    isNew: i >= indexOfFirstChange && i < indexOfLastChange,\n  }))\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const { char } = rawValueArr[i]\n\n    if (char !== placeholderChar) {\n      const shouldOffset =\n        i >= indexOfFirstChange &&\n        previousConformedValueLength === maskLength\n\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1)\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString\n  let someCharsRejected = false\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i]\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const { char: rawValueChar, isNew } = rawValueArr.shift()\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length\n              let indexOfNextAvailablePlaceholderChar = null\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let i = 0; i < rawValueArrLength; i++) {\n                const charData = rawValueArr[i]\n\n                if (\n                  charData.char !== placeholderChar &&\n                  charData.isNew === false\n                ) {\n                  break\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = i\n                  break\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1)\n\n                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                i--\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop\n          } else {\n            someCharsRejected = true\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength)\n      }\n\n      // And we break\n      break\n\n      // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(\n        0,\n        indexOfLastFilledPlaceholderChar + 1\n      )\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString\n    }\n  }\n\n  return { conformedValue, meta: { someCharsRejected } }\n}\n","/**\n * Source for a non maintained repo:\n * https://github.com/text-mask/text-mask/tree/master/core/src\n */\n\nimport adjustCaretPosition from './adjustCaretPosition'\nimport conformToMask from './conformToMask'\nimport {\n  convertMaskToPlaceholder,\n  isString,\n  isNumber,\n  processCaretTraps,\n} from './utilities'\nimport {\n  placeholderChar as defaultPlaceholderChar,\n  strFunction,\n} from './constants'\n\nconst emptyString = ''\nconst strObject = 'object'\nconst isAndroid =\n  typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent)\nconst defer =\n  typeof requestAnimationFrame !== 'undefined'\n    ? requestAnimationFrame\n    : setTimeout\n\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  const state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined,\n  }\n\n  return {\n    state,\n\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update(\n      rawValue,\n      {\n        inputElement,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n      } = config\n    ) {\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value\n      }\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) {\n        return\n      }\n\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (\n        typeof providedMask === strObject &&\n        providedMask.pipe !== undefined &&\n        providedMask.mask !== undefined\n      ) {\n        pipe = providedMask.pipe\n        providedMask = providedMask.mask\n      }\n\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      let placeholder\n\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      let mask\n\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(\n          providedMask,\n          placeholderChar\n        )\n      }\n\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (providedMask === false) {\n        return\n      }\n\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      const safeRawValue = getSafeRawValue(rawValue)\n\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      const currentCaretPosition = inputElement?.selectionEnd\n\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      const { previousConformedValue, previousPlaceholder } = state\n\n      let caretTrapIndexes\n\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === strFunction) {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition,\n          previousConformedValue,\n          placeholderChar,\n        })\n\n        // disable masking if `mask` is `false`\n        if (mask === false) {\n          return\n        }\n\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        const { maskWithoutCaretTraps, indexes } = processCaretTraps(mask)\n\n        mask = maskWithoutCaretTraps // The processed mask is what we're interested in\n        caretTrapIndexes = indexes // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar)\n\n        // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask\n      }\n\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      const conformToMaskConfig = {\n        previousConformedValue,\n        guide,\n        placeholderChar,\n        pipe,\n        placeholder,\n        currentCaretPosition,\n        keepCharPositions,\n      }\n\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      const { conformedValue } = conformToMask(\n        safeRawValue,\n        mask,\n        conformToMaskConfig\n      )\n\n      // The following few lines are to support the `pipe` feature.\n      const piped = typeof pipe === strFunction\n\n      let pipeResults = {}\n\n      // If `pipe` is a function, we call it.\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, {\n          rawValue: safeRawValue,\n          ...conformToMaskConfig,\n        })\n\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = { value: previousConformedValue, rejected: true }\n        } else if (isString(pipeResults)) {\n          pipeResults = { value: pipeResults }\n        }\n      }\n\n      // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      const finalConformedValue = piped\n        ? pipeResults.value\n        : conformedValue\n\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      const adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue,\n        previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition,\n        placeholderChar,\n        indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n        caretTrapIndexes,\n      })\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty =\n        finalConformedValue === placeholder && adjustedCaretPosition === 0\n      const emptyValue = showMask ? placeholder : emptyString\n      const inputElementValue = inputValueShouldBeEmpty\n        ? emptyValue\n        : finalConformedValue\n\n      state.previousConformedValue = inputElementValue // store value for access for next time\n      state.previousPlaceholder = placeholder\n\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return\n      }\n\n      inputElement.value = inputElementValue // set the input value\n      safeSetSelection(inputElement, adjustedCaretPosition) // adjust caret position\n    },\n  }\n}\n\nexport function safeSetSelection(element, selectionPosition) {\n  if (\n    document.activeElement === element ||\n    element?.setSelectionRange?.name === 'mockConstructor'\n  ) {\n    if (isAndroid) {\n      defer(\n        () =>\n          element.setSelectionRange(selectionPosition, selectionPosition),\n        0\n      )\n    } else {\n      element?.setSelectionRange(selectionPosition, selectionPosition)\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue\n  } else if (isNumber(inputValue)) {\n    return String(inputValue)\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString\n  } else {\n    throw new Error(\n      \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n        `received was:\\n\\n ${JSON.stringify(inputValue)}`\n    )\n  }\n}\n","import { placeholderChar as defaultPlaceholderChar } from './constants'\n\nconst emptyArray = []\n\nexport function convertMaskToPlaceholder(\n  mask = emptyArray,\n  placeholderChar = defaultPlaceholderChar\n) {\n  if (!isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.'\n    )\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n        'that is not present in your mask as your placeholder character.\\n\\n' +\n        `The placeholder character that was received is: ${JSON.stringify(\n          placeholderChar\n        )}\\n\\n` +\n        `The mask that was received is: ${JSON.stringify(mask)}`\n    )\n  }\n\n  return mask\n    .map((char) => {\n      return char instanceof RegExp ? placeholderChar : char\n    })\n    .join('')\n}\n\nexport function isArray(value) {\n  return (Array.isArray && Array.isArray(value)) || value instanceof Array\n}\n\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport function isNumber(value) {\n  return (\n    typeof value === 'number' &&\n    value.length === undefined &&\n    !isNaN(value)\n  )\n}\n\nexport function isNil(value) {\n  return typeof value === 'undefined' || value === null\n}\n\nconst strCaretTrap = '[]'\nexport function processCaretTraps(mask) {\n  const indexes = []\n\n  let indexOfCaretTrap\n  while (\n    ((indexOfCaretTrap = mask.indexOf(strCaretTrap)),\n    indexOfCaretTrap !== -1)\n  ) {\n    // eslint-disable-line\n    indexes.push(indexOfCaretTrap)\n\n    mask.splice(indexOfCaretTrap, 1)\n  }\n\n  return { maskWithoutCaretTraps: mask, indexes }\n}\n"],"names":["Lead","_ref","className","rest","_jsx","P","classnames","_supportsSpacingProps","BooleanComponent","props","trueText","falseText","restProps","translations","useTranslation","BooleanField","ToggleField","valueOn","valueOff","textOn","yes","textOff","no","valueType","Name","StringFieldProps","trim","autoComplete","pattern","StringField","First","FirstName","errorMessages","useErrorMessage","path","required","errorRequired","errorPattern","nameProps","label","Last","LastName","Company","CompanyName","undefined","StringComponent","_props$width","_value$toString","fieldBlockContext","useContext","FieldBlockContext","Field","minLength","errorMinLength","maxLength","errorMaxLength","schema","useMemo","_props$schema","type","fromInput","useCallback","event","_event","_event$cleanedValue","_event2","_event3","value","emptyValue","cleanedValue","toEvent","spaces","RegExp","test","replace","handleChange","transform","transformValue","capitalize","toCapitalized","String","preparedProps","width","composition","id","name","innerRef","inputClassName","layout","placeholder","labelDescription","info","warning","error","hasError","disabled","help","multiline","mask","leftIcon","rightIcon","htmlAttributes","submitElement","clear","align","size","selectall","keepPlaceholder","rows","autoresizeMaxRows","autoresize","characterCounter","inputMode","autoCorrect","spellCheck","autoFocus","autoCapitalize","handleFocus","handleBlur","useFieldProps","transformInstantly","sharedProps","suffix","HelpButton","title","children","content","on_focus","on_blur","on_change","stretch","Boolean","inner_ref","status","toString","textareaProps","autoresize_max_rows","inputProps","icon","icon_position","submit_element","keep_placeholder","fieldSectionProps","forId","contentWidth","pickSpacingProps","FieldBlock","Textarea","InputMasked","Input","Toggle","variant","handleCheckboxChange","checked","handleToggleChange","_ref2","cn","fieldSectionPropsWithoutLabel","isOn","isOff","Checkbox","onChange","ToggleButton","text","asFieldset","ButtonRow","bottom","_jsxs","ToggleButtonGroupContext","Provider","Space","SectionComponent","_nestedProps$overwrit","overwriteProps","errorPrioritization","startsWith","Error","nestedPath","handleNestedChange","nestedProps","SectionContext","dataRef","useRef","pointer","current","identifier","fieldProps","FieldPropsProvider","substring","SubmitButton","showIndicator","sendText","formState","handleSubmit","isInsideFormElement","DataContext","onClickHandler","Button","onClick","send","SubmitIndicator","state","Visibility","visible","pathDefined","pathUndefined","pathTruthy","pathFalsy","pathTrue","pathFalse","pathValue","whenValue","visibleWhen","visibleWhenNot","inferData","filterData","animate","keepInDOM","fieldPropsWhenHidden","dataContext","sectionContext","sectionPath","composePath","useMountEffect","warn","open","check","_dataContext$filterDa","data","filterDataHandler","call","_visibleWhen","_visibleWhen2","withValue","result","Object","prototype","hasOwnProperty","getValue","HeightAnimation","FieldProps","hidden","_Fragment","defaultErrorMessages","context","Context","fromContext","contextErrorMessages","xmlns","height","fill","viewBox","stroke","strokeLinecap","strokeLinejoin","strokeWidth","d","React","emptyString","minusRegExp","nonDigitsRegExp","number","digitRegExp","convertToMask","strNumber","split","map","char","enableLocaleSupportWhen","enableNumberMaskWhen","invisibleSpace","isRequestingNumberMask","entries","some","k","v","includes","correctNumberValue","_ref3","localValue","locale","maskParams","isNaN","parseFloat","decimalPos","indexOf","integerLimit","limit","integers","isNegative","length","decimals","slice","shouldHaveDecimals","allowDecimal","decimalLimit","number_format","options","format","decimalSymbol","localNumberValue","numberValue","endsWithDecimal","endsWith","endsWithZeroAndDecimal","getSoftKeyboardAttributes","instanceOf","IS_IOS","allowNegative","fromJSON","str","fallback","JSON","parse","useLayoutEffect","window","InputMaskedContext","useNumberMask","useNumberMaskParams","_temp","prefix","includeThousandsSeparator","thousandsSeparatorSymbol","requireDecimal","prefixLength","suffixLength","numberMask","rawValue","rawValueLength","concat","substr","indexOfLastDecimal","lastIndexOf","hasDecimal","integer","fraction","n","addThousandsSeparator","push","createNumberMask","useMask","useMaskParams","keep_char_positions","show_guide","show_mask","placeholder_char","showMask","isTrue","placeholderChar","showGuide","keepCharPositions","useCallEvent","setLocalValue","isNumberMask","decimalSeparators","isUnidentified","callEvent","target","selStart","selectionStart","keyCode","keycode","which","disallowLeadingZeroes","testValue","preventDefault","hasDecimalSymbol","allowedDecimals","charAtSelection","index","safeSetSelection","num","cleanNumber","decimalSeparator","thousandsSeparator","Number","charAt","runCorrectCaretPosition","correctCaretPosition","element","correction","start","end","selectionEnd","suffixStart","suffixEnd","pos","prefixStart","prefixEnd","chars","l","i","_mask$test","e","requestAnimationFrame","__getCorrectCaretPosition","dispatchCustomElementEvent","_currency_mask","mask_options","number_mask","currency_mask","as_number","as_percent","as_currency","currency","isRequestingLocaleSupport","getThousandsSeparator","handleThousandsSeparator","getDecimalSeparator","handleDecimalSeparator","extendPropsWithContext","_currency_mask2","getCurrencySymbol","currencyDisplay","_ref6","handleNumberMask","_ref4","_String","_String$match","percent","match","handlePercentMask","_ref5","fix","handleCurrencyMask","InputMaskedElement","inputElement","useInputElement","pipe","isFn","refHook","ref","inputElementRef","InputElement","params","TextMask","inputRef","guide","useLocalValue","events","onBeforeInput","onFocus","onBlur","onMouseUp","onMouseDown","onKeyDown","onSubmit","on_key_down","on_submit","useEventMapping","useFilteredProps","attributes","freeze","input_element","alias","key","contextAndProps","defaultProps","on_submit_focus","on_submit_blur","_formElement","InputModeNumber","this","hasFocus","clearTimeout","timeout","setTimeout","_this$inputElement$ru","_this$inputElement","_proto","setElement","focusEventName","blurEventName","add","handleLabel","_this$inputElement2","labelElement","document","querySelector","addEventListener","_this$inputElement3","fnId","removeEvent","removeEventListener","remove","_React$PureComponent","_this","textMaskInputElement","update","_inheritsLoose","componentDidMount","initTextMask","componentWillUnmount","_this$inputMode","_this$inputMode2","createTextMaskInputElement","componentDidUpdate","prevProps","settings","isPipeChanged","isNil","isMaskChanged","isSettingChanged","keys","prop","render","strFunction","defaultArray","emptyArray","strObject","isAndroid","navigator","userAgent","defer","config","previousConformedValue","previousPlaceholder","providedMask","defaultPlaceholderChar","Array","convertMaskToPlaceholder","safeRawValue","inputValue","isString","isNumber","stringify","getSafeRawValue","currentCaretPosition","caretTrapIndexes","maskWithoutCaretTraps","indexes","processCaretTraps","conformToMaskConfig","conformedValue","isArray","suppressGuide","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","rawValueArr","isNew","splice","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","meta","conformToMask","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","indexesOfPipedChars","conformedValueLength","editLength","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","intersection","filter","previousLeftMaskChars","masklengthChanged","targetIsMaskMovingLeft","countTargetCharInPipedChars","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","adjustCaretPosition","inputElementValue","selectionPosition","_element$setSelection","activeElement","setSelectionRange","join","strCaretTrap","indexOfCaretTrap"],"sourceRoot":""}