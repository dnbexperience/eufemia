"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[71694,73176,96124],{19452:function(e,n,r){r.r(n);var t=r(52322),s=r(45392),a=r(99201),o=r(72945);function i(e){const n=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",strong:"strong",ul:"ul",li:"li",a:"a",ol:"ol",h4:"h4",h5:"h5"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Form.Handler"})," is the root component of your form. It provides a HTML form element and handles the form data."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nconst existingData = { firstName: 'Nora' }\n\nfunction MyForm() {\n  return (\n    <Form.Handler\n      defaultData={existingData}\n      onSubmit={...}\n    >\n      Your Form\n    </Form.Handler>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h3,{children:"TypeScript support"}),"\n",(0,t.jsx)(n.p,{children:"You can define the TypeScript type structure for your form data. This will help you to get better code completion and type checking."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"NB:"})," Use ",(0,t.jsx)(n.code,{children:"type"})," instead of ",(0,t.jsx)(n.code,{children:"interface"})," for the type definition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\ntype MyData = {\n  firstName?: string\n}\n\n// Method #1 – without initial data\nfunction MyForm() {\n  return (\n    <Form.Handler<MyData>\n      onSubmit={(data) => {\n        console.log(data.firstName satisfies string)\n      }}\n    >\n      ...\n    </Form.Handler>\n  )\n}\n\n// Method #2 – with data (initial values)\nconst existingData: MyData = {\n  firstName: 'Nora',\n}\nfunction MyForm() {\n  return (\n    <Form.Handler\n      defaultData={existingData}\n      onSubmit={(data) => {\n        console.log(data.firstName satisfies string)\n      }}\n    >\n      ...\n    </Form.Handler>\n  )\n}\n\n// Method #3 – type definition for the submit handler\nimport type { OnSubmit } from '@dnb/eufemia/extensions/forms'\nconst submitHandler: OnSubmit<MyData> = (data) => {\n  console.log(data.firstName satisfies string)\n}\nfunction MyForm() {\n  return <Form.Handler onSubmit={submitHandler}>...</Form.Handler>\n}\n\n// Method #4 – type definition on the event parameter\nfunction MyForm() {\n  return (\n    <Form.Handler\n      onSubmit={(data: MyData) => {\n        console.log(data.firstName satisfies string)\n      }}\n    >\n      ...\n    </Form.Handler>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"To disable types you can:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"<Form.Handler<any>>...</Form.Handler>\n"})}),"\n",(0,t.jsx)(n.h2,{children:"Decoupling the form element"}),"\n",(0,t.jsxs)(n.p,{children:["For more flexibility, you can decouple the form element from the form context by using the ",(0,t.jsx)(n.code,{children:"decoupleForm"})," property. It is recommended to use the ",(0,t.jsx)(n.code,{children:"Form.Element"})," to wrap your rest of your form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nfunction MyApp() {\n  return (\n    <Form.Handler decoupleForm>\n      <AppRelatedThings>\n        <Form.Element>\n          <Form.MainHeading>Heading</Form.MainHeading>\n          <Form.Card>\n            <Field.Email />\n          </Form.Card>\n          <Form.SubmitButton />\n        </Form.Element>\n      </AppRelatedThings>\n    </Form.Handler>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h2,{children:"Data handling"}),"\n",(0,t.jsxs)(n.p,{children:["You can access, mutate and filter data inside of the form context by using the ",(0,t.jsx)(n.code,{children:"Form.useData"})," hook:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nfunction MyComponent() {\n  const {\n    getValue,\n    update,\n    remove,\n    set,\n    data,\n    filterData,\n    reduceToVisibleFields,\n  } = Form.useData()\n\n  return <>...</>\n}\n\nfunction MyApp() {\n  return (\n    <>\n      <Form.Handler>...</Form.Handler>\n      <MyComponent />\n    </>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"getValue"})," will return the value of the given path."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"update"})," will update the value of the given path."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"remove"})," will remove the given path from the data context (fields will reapply their values afterwards)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"set"})," will set the whole dataset."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"})," will return the whole dataset (unvalidated)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filterData"})," will filter the data based on your own logic."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"reduceToVisibleFields"})," will reduce the given data set to only contain the visible fields (mounted fields)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{children:"Using a form ID"}),"\n",(0,t.jsx)(n.p,{children:"The form data can be handled outside of the form. This is useful if you want to use the form data in other components:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nconst myFormId = 'unique-id' // or a function, object or React Context reference\n\nfunction MyComponent() {\n  const { data } = Form.useData(myFormId)\n\n  return <>...</>\n}\n\nfunction MyApp() {\n  return (\n    <>\n      <Form.Handler id={myFormId}>...</Form.Handler>\n      <MyComponent />\n    </>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["More examples can be found in the ",(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/Form/useData/",children:"useData"})," hook docs."]}),"\n",(0,t.jsxs)(n.h2,{children:["Async ",(0,t.jsx)(n.code,{children:"onChange"})," and ",(0,t.jsx)(n.code,{children:"onSubmit"})," event handlers"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"NB:"})," When using an async ",(0,t.jsx)(n.code,{children:"onChange"})," event handler, the ",(0,t.jsx)(n.code,{children:"data"})," parameter will only include validated data. This lets you utilize the ",(0,t.jsx)(n.code,{children:"data"})," parameter directly in your request, without having to further process or transform it."]}),"\n",(0,t.jsxs)(n.p,{children:["If you need to use the original data (sync), you can access it via the ",(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/Form/useData/",children:"useData"})," hook."]}),"\n",(0,t.jsxs)(n.p,{children:["Depending on your needs, you may want to use e.g. ",(0,t.jsx)(n.code,{children:"debounceAsync"})," (",(0,t.jsx)(n.a,{href:"/uilib/helpers/functions/#debounce",children:"debounce"}),") to prevent multiple requests from being sent."]}),"\n",(0,t.jsxs)(n.p,{children:["You can return parameters from inside the async ",(0,t.jsx)(n.code,{children:"onChange"})," or ",(0,t.jsx)(n.code,{children:"onSubmit"})," event handler. This way you can display more related information, such as an error or an object with these keys:"]}),"\n",(0,t.jsx)(o.default,{}),"\n",(0,t.jsx)(a.default,{}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"info"}),", ",(0,t.jsx)(n.code,{children:"warning"})," and ",(0,t.jsx)(n.code,{children:"error"})," messages will be displayed at the bottom of a form or field (",(0,t.jsx)(n.a,{href:"/uilib/components/form-status",children:"FormStatus"}),"), depending where it is used. While the ",(0,t.jsx)(n.code,{children:"success"})," will be displayed on the label of the field that initiated the ",(0,t.jsx)(n.code,{children:"onChange"})," event."]}),"\n",(0,t.jsx)(n.h2,{children:"Browser autofill"}),"\n",(0,t.jsxs)(n.p,{children:["You can set ",(0,t.jsx)(n.code,{children:"autoComplete"})," on the ",(0,t.jsx)(n.code,{children:"Form.Handler"})," – each ",(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/base-fields/String/",children:"Field.String"}),"-field will then get ",(0,t.jsx)(n.code,{children:'autoComplete="on"'}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'<Form.Handler autoComplete={true}>\n  <Field.String path="/firstName" />\n  <Field.String path="/firstName" />\n</Form.Handler>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"path"})," property will be used to set the ",(0,t.jsx)(n.code,{children:"name"})," attribute, which lets browser know which autocomplete value should be proposed to the user."]}),"\n",(0,t.jsx)(n.h2,{children:"Temporary storage"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"sessionStorageId"})," feature uses the browsers session-storage (temporary storage mechanism) to store data entered by the user."]}),"\n",(0,t.jsx)(n.p,{children:"This lets the user navigate away and come back to the form, without loosing already entered data."}),"\n",(0,t.jsx)(n.p,{children:"Ensure you only use this feature for non-sensitive data."}),"\n",(0,t.jsx)(n.p,{children:"It will flush the storage once the form gets submitted."}),"\n",(0,t.jsx)(n.h2,{children:"Visible data"}),"\n",(0,t.jsxs)(n.p,{children:["You can use the ",(0,t.jsx)(n.code,{children:"reduceToVisibleFields"})," function to get only the data of visible (mounted) fields."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nrender(\n  <Form.Handler\n    onSubmit={(data, { reduceToVisibleFields }) => {\n      const myData = reduceToVisibleFields(data, {\n        keepPaths: ['/foo'],\n        removePaths: ['/bar'],\n      })\n    }}\n  >\n    <Form.SubmitButton />\n  </Form.Handler>,\n)\n"})}),"\n",(0,t.jsx)(n.h2,{children:"Filter data"}),"\n",(0,t.jsxs)(n.p,{children:["You can use the ",(0,t.jsx)(n.code,{children:"filterData"})," function to filter your ",(0,t.jsx)(n.code,{children:"onSubmit"})," data. It might be useful, for example, to ",(0,t.jsx)(n.strong,{children:"exclude disabled fields"})," or filter out empty fields. The callback function receives the following arguments:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"path"})," as the first argument."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," as the second argument."]}),"\n",(0,t.jsxs)(n.li,{children:["The field ",(0,t.jsx)(n.code,{children:"properties"})," (props) as the third argument."]}),"\n",(0,t.jsx)(n.li,{children:"The fourth argument is an object with the internal state of the field, like the error state."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The callback function should return a ",(0,t.jsx)(n.code,{children:"boolean"})," or ",(0,t.jsx)(n.code,{children:"undefined"}),". Return ",(0,t.jsx)(n.code,{children:"false"})," to exclude an entry."]}),"\n",(0,t.jsx)(n.p,{children:"It returns the filtered form data."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/Form/useData/#filter-data",children:"useData"})," hook and the ",(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/Form/getData/#filter-data",children:"getData"})," method also returns a ",(0,t.jsx)(n.code,{children:"filterData"})," function you can use to filter data the same way."]}),"\n",(0,t.jsxs)(n.p,{children:["In the demo section is an example of how to use the ",(0,t.jsx)(n.code,{children:"filterData"})," method."]}),"\n",(0,t.jsx)(n.h3,{children:"Filter arrays"}),"\n",(0,t.jsxs)(n.p,{children:["You can filter arrays by using the ",(0,t.jsx)(n.code,{children:"filterData"})," method. You can find more information about this in the ",(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/Iterate/Array/#filter-data",children:"Iterate.Array"})," docs."]}),"\n",(0,t.jsx)(n.h3,{children:"onSubmit parameters"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onSubmit"})," event returns additional functions you can call:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filterData"})," Filters the given/internal data set."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"reduceToVisibleFields"})," Reduces the given data set to only contain the visible fields (mounted fields)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"transformData"})," Will call the given function for each data path. The returned ",(0,t.jsx)(n.code,{children:"value"})," will replace each data entry. It's up to you to define the shape of the value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"resetForm"})," Deletes ",(0,t.jsx)(n.code,{children:"sessionStorage"})," and browser stored autocomplete data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"clearData"})," Empties the given/internal data set."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nconst myFilter = {\n  '/myPath': (value) => {\n    return value.length > 0\n  },\n}\n\nconst MyForm = () => {\n  return (\n    <Form.Handler\n      onSubmit={(\n        data,\n        {\n          filterData,\n          reduceToVisibleFields,\n          transformData,\n          resetForm,\n          clearData,\n        },\n      ) => {\n        resetForm()\n        clearData()\n\n        const filteredData = filterData(myFilter)\n        const myData = reduceToVisibleFields(filteredData)\n        const transformed = transformData(\n          myData,\n          ({ path, value, displayValue, label, props, internal }) => {\n            return 'new value'\n          },\n        )\n      }}\n      sessionStorageId=\"session-key\"\n    >\n      <Form.SubmitButton />\n    </Form.Handler>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h4,{children:(0,t.jsx)(n.code,{children:"transformData"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"transformData"})," function will call the given function for each data path. The returned ",(0,t.jsx)(n.code,{children:"value"})," will replace each data entry. It's up to you to define the shape of the value."]}),"\n",(0,t.jsx)(n.p,{children:"The callback function receives the following arguments as an object:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"path"})," The path of the field."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," The value of the field."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"displayValue"})," The displayed value of the field."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"label"})," The label of the field."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"props"})," The given field properties."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"internal"})," The ",(0,t.jsx)(n.code,{children:"internal"})," parameter contains ",(0,t.jsx)(n.code,{children:"{ error: Error | undefined }"})," you can utilize if needed."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"displayValue"})," can be ",(0,t.jsx)(n.code,{children:"undefined"})," if a field does not support it, or it's value is not set (",(0,t.jsx)(n.code,{children:"emptyValue"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Most of the fields will return the ",(0,t.jsx)(n.code,{children:"displayValue"})," as a string. But there are some exceptions:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/uilib/extensions/forms/base-fields/ArraySelection/",children:"ArraySelection"})," will return the displayed/active options content as an array that contains a string (or React.ReactNode)."]}),"\n"]}),"\n",(0,t.jsxs)(n.h5,{children:[(0,t.jsx)(n.code,{children:"displayValue"})," from fields inside Iterate.Array"]}),"\n",(0,t.jsxs)(n.p,{children:["When using the ",(0,t.jsx)(n.code,{children:"Iterate.Array"})," component, you may check if the current entry is an array. This way you ensure you never transform the array itself, but only the values from the fields inside the array."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'import { Form } from \'@dnb/eufemia/extensions/forms\'\n\nconst MyForm = () => {\n  return (\n    <Form.Handler\n      onSubmit={(data, { transformData }) => {\n        const transformedData = transformData(\n          data,\n          ({ value, displayValue, label }) => {\n            if (!Array.isArray(value)) {\n              return { value, displayValue, label }\n            }\n          },\n        )\n      }}\n    >\n      <Form.Card>\n        <Iterate.Array path="/myArray">\n          <Field.String itemPath="/" label="My label" />\n        </Iterate.Array>\n      </Form.Card>\n      <Form.SubmitButton />\n    </Form.Handler>\n  )\n}\n'})})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(i,e)})):i(e)}},72945:function(e,n,r){r.r(n);var t=r(52322),s=r(45392);function a(e){const n=Object.assign({pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// Async event handler\nconst onChange = debounceAsync(async function (data) {\n  try {\n    await makeRequest(data)\n  } catch (error) {\n    return error\n  }\n\n  // Optionally, you can return an object with these keys, depending your needs\n  return {\n    info: 'Info message',\n    warning: 'Warning message',\n\n    // and either an error\n    error: new Error('Error message'),\n\n    // or success (when used for autosave)\n    success: 'saved',\n  } as const\n})\n"})})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(a,e)})):a(e)}},99201:function(e,n,r){r.r(n);var t=r(52322),s=r(45392);function a(e){const n=Object.assign({p:"p",pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In all async operations, you can simply return an error object to display it in the form or influence the form behavior."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { Form } from '@dnb/eufemia/extensions/forms'\n\nconst myFormId = 'unique-id' // or a function, object or React Context reference\n\n// Async function\nconst onSubmit = async (data) => {\n  try {\n    const response = await fetch('https://api.example.com', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    })\n    const data = await response.json()\n\n    Form.setData(myFormId, data) // Whatever you want to do with the data\n  } catch (error) {\n    return error // Will display the error message in the form\n  }\n\n  // Optionally, you can return an object with these keys, depending your needs\n  return {\n    info: 'Info message',\n    warning: 'Warning message',\n\n    // Force the form to stay in pending state\n    status: 'pending',\n\n    // and either an error\n    error: new Error('Error message'),\n  } as const\n}\n\nfunction Component() {\n  return (\n    <Form.Handler id={myFormId} onSubmit={onSubmit}>\n      ...\n    </Form.Handler>\n  )\n}\n"})})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(a,e)})):a(e)}}}]);
//# sourceMappingURL=c7b51beff648d4b480ed48f3ffd9f5aa29c3f5b2-ea0bc1fcb526df6b6642.js.map