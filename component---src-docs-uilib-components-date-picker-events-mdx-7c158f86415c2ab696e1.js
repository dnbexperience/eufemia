"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[39456],{90642:function(e,n,t){t.r(n);var s=t(52322),i=t(45392),d=t(83500);function l(e){const n=Object.assign({h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",code:"code",em:"em",p:"p",pre:"pre",h3:"h3",a:"a"},(0,i.ah)(),e.components),{VisibleWhenNotVisualTest:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("VisibleWhenNotVisualTest",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{children:"Events"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Events"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_change"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called on a date change event. Returns an ",(0,s.jsx)(n.code,{children:"object"}),". See Returned Object below."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_type"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called on every input and date picker interaction. Returns an ",(0,s.jsx)(n.code,{children:"object"}),". See Returned Object below."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_submit"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once a user presses the submit button."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_cancel"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once a user presses the cancel button."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_reset"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once a user presses the reset button."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_show"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once date-picker is visible."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_hide"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once date-picker is hidden."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_days_render"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called right before every new calendar view gets rendered. See the example above."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onFocus"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once the input gets focus."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onBlur"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(optional)"})," will be called once the input lose focus."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{children:"Returned Object"}),"\n",(0,s.jsx)(n.p,{children:"The type of native event will depend on the interaction.\nAll additional HTML attributes will be returned as well."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  date: null|'like return_format', /* Gets returned if range is false */\n  start_date: null|'like return_format',\n  end_date: null|'like return_format',\n  days_between: number,\n  attributes: { attributes },\n  event: null|{ native event }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Validation during input changes"}),"\n",(0,s.jsxs)(n.p,{children:["In order to validate dates during typing, you can make use of ",(0,s.jsx)(n.code,{children:"is_valid"})," or ",(0,s.jsx)(n.code,{children:"is_valid_start_date"})," and ",(0,s.jsx)(n.code,{children:"is_valid_end_date"}),". Because the user can change a date in the input field, and the ",(0,s.jsx)(n.code,{children:"on_type"})," event will then return a falsy ",(0,s.jsx)(n.code,{children:"is_valid"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Additional event return object properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  is_valid: boolean, /* Gets returned if range is false */\n  is_valid_start_date: boolean,\n  is_valid_end_date: boolean,\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Min & Max date"}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"min_date"})," or ",(0,s.jsx)(n.code,{children:"max_date"})," is given, the return object also contains info about if the ",(0,s.jsx)(n.code,{children:"start_date"})," or ",(0,s.jsx)(n.code,{children:"end_date"})," is in between the given limits. The reason is that the user can still enter an invalid date in the input."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  is_valid_start_date: boolean,\n  is_valid_end_date: boolean,\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Manipulate the days in the calendar view"}),"\n",(0,s.jsxs)(n.p,{children:["The callback event ",(0,s.jsx)(n.code,{children:"on_days_render"}),' gives you the possibility to manipulate the "day" object, before it gets rendered. This callback will be called many times. Both on the first render, and on every user interaction, like hover and selection, etc. This means you have to ensure a performant date calculation.']}),"\n",(0,s.jsxs)(n.p,{children:["Please use ",(0,s.jsx)(n.a,{href:"https://date-fns.org",children:"date-fns"})," to make the calculations."]}),"\n",(0,s.jsx)(t,{children:(0,s.jsx)(d.QP,{})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"dayObject"})," object contains:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"[\n    {\n      date: Date,// Vanilla JavaScript Date object\n      className: // define your custom css classes\n      isInactive: boolean,// shows it as disabled only\n      isDisabled: boolean,// shows it as disabled and with a strikethrough\n      isPreview: boolean,// date is between startDate (exclusive) and hoverDate (inclusive)\n      isSelectable: boolean,// if not last and next month and not disabled â€“ handles z-index\n      isStartDate: boolean,// date selected is start date\n      isEndDate: boolean,// date selected is end date\n      isToday: boolean,\n      isWithinSelection: boolean,// date is between selection range\n      isNextMonth: boolean,// used for selection and inactive calculation\n      isLastMonth: boolean,// used for selection and inactive calculation\n    },\n    ...\n]\n"})})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}}}]);
//# sourceMappingURL=component---src-docs-uilib-components-date-picker-events-mdx-7c158f86415c2ab696e1.js.map