"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[35641],{13442:function(e,n,r){r.r(n);var s=r(52322),o=r(45392);function i(e){const n=Object.assign({h1:"h1",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",ul:"ul",li:"li",strong:"strong",a:"a",h4:"h4",ol:"ol"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"Description"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useDataValue"})," hook standardize handling of the value flow for a single consumer component representing one data point. It holds error state, hides it while the field is in focus, connects to surrounding ",(0,s.jsx)(n.code,{children:"DataContext"})," (if present) and other things that all field or value components needs to do. By implementing custom field or value components and passing the received props through ",(0,s.jsx)(n.code,{children:"useDataValue"}),", all these features work the same way as other field or value components, and you only need to implement the specific unique features of that component."]}),"\n",(0,s.jsx)(n.h2,{children:"How to use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useDataValue } from '@dnb/eufemia/extensions/forms'\nconst { value } = useDataValue(componentProps)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Advanced usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import {\n  useDataValue,\n  useErrorMessage,\n} from '@dnb/eufemia/extensions/forms'\n\nconst sharedContext = useContext(SharedContext)\nconst tr = sharedContext?.translation.Forms\n\nconst errorMessages = useErrorMessage(props.path, props.errorMessages, {\n  // Your default error messages\n  required: tr.inputErrorRequired,\n  pattern: tr.inputErrorPattern,\n})\n\nconst preparedProps = {\n  errorMessages,\n  // Your component props\n  ...props,\n}\n\nconst {\n  // Return Parameters:\n  value,\n  onChange,\n  onFocus,\n  onBlur,\n  error,\n  hasError,\n  isChanged,\n  setHasFocus,\n  ariaAttributes,\n\n  // Component Properties\n  ...rest\n} = useDataValue(preparedProps)\n\nrender(\n  <Input\n    value={value}\n    onChange={onChange}\n    onFocus={onFocus}\n    onBlur={onBlur}\n    {...ariaAttributes}\n  />,\n)\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Internal Properties"}),"\n",(0,s.jsx)(n.p,{children:"All properties are optional and can be used as needed. These properties can be provided as part of your component properties."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"value"})," the input value (string)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"emptyValue"})," defines what value is considered to be empty. Defaults to ",(0,s.jsx)(n.code,{children:"undefined"}),". But an empty string is also validated when required is true."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"path"})," the JSON pointer that defines the entry name/key in the data structure."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Validation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"required"})," if true, it will call ",(0,s.jsx)(n.code,{children:"validateRequired"})," for validation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"schema"})," or ",(0,s.jsx)(n.code,{children:"pattern"})," for JSON schema validation powered by ",(0,s.jsx)(n.a,{href:"https://ajv.js.org/",children:"ajv"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validator"})," your custom validation function. It will run on every keystroke."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validateRequired"})," does allow you to provide a custom logic for how the ",(0,s.jsx)(n.code,{children:"required"})," prop should validate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onBlurValidator"})," your custom validation function. It will run on a ",(0,s.jsx)(n.code,{children:"handleBlur()"})," call. Use it over ",(0,s.jsx)(n.code,{children:"validator"})," for validations with side-effects."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validateInitially"})," in order to show an error without a change and blur event. Used for rare cases."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validateUnchanged"})," in order to validate without a change and blur event. Used for rare cases."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"continuousValidation"})," in order to validate without a focus event beforehand. Used for rare cases."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," object like ",(0,s.jsx)(n.code,{children:"FormError"})," that includes the string to display or an object with the key ",(0,s.jsx)(n.code,{children:"validationRule"}),". More info down below."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"errorMessages"})," object with your custom messages, where each key represents a ",(0,s.jsx)(n.code,{children:"validationRule"}),". More info down below."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Return Parameters"}),"\n",(0,s.jsx)(n.p,{children:"It returns all of the given component properties, in addition to these:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"value"})," the output value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"})," creates a memorized id."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dataContext"})," the internal shared data context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," the error object, in case an error is invoked. Will skip returning the error object, if the hook is used in a nested ",(0,s.jsx)(n.a,{href:"/uilib/extensions/forms/create-component/FieldBlock/",children:"FieldBlock"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hasError"})," will return true in case of an error, even if the hook is nested in a ",(0,s.jsx)(n.code,{children:"FieldBlock"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ariaAttributes"})," object that include needed aria attributes, ready to be spread on form elements."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isChanged"})," returns ",(0,s.jsx)(n.code,{children:"true"})," if the value has changed with e.g. ",(0,s.jsx)(n.code,{children:"handleChange"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"setHasFocus"})," accepts a boolean as value. When called, it will update the internal logic - for event handling and validation. Will re-render the React Hook and its outer component."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onFocus"})," event handler to assign to a form element."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onBlur"})," event handler to assign to a form element."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onChange"})," event handler to assign to a form element."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Custom validateRequired"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const validateRequired = (\n  value: Value,\n  { emptyValue, required, isChanged },\n) => {\n  return required && value === emptyValue\n    ? new FormError('The value is required', {\n        validationRule: 'required',\n      })\n    : undefined\n}\n\nconst { error, hasError } = useDataValue({\n  value: undefined,\n  required: true,\n  validateInitially: true,\n  validateRequired,\n  errorMessages: {\n    required: 'Show this when \"required\" fails!',\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Validation order"}),"\n",(0,s.jsx)(n.p,{children:"During validation, the different APIs do have a prioritization order and will stop processing further when they match:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"required"})," prop"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"schema"})," prop (including ",(0,s.jsx)(n.code,{children:"pattern"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validator"})," prop"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Error handling"}),"\n",(0,s.jsx)(n.p,{children:"Validation and error-handling is tight coupled together. When a validation fails, you may use the error-object to handle and show the failures/statuses."}),"\n",(0,s.jsxs)(n.p,{children:["To generate the error-object, ",(0,s.jsx)(n.code,{children:"FormError"})," is used. You can use it as well:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { FormError } from \'@dnb/eufemia/extensions/forms\'\nrender(\n  <Field.String\n    label="Label"\n    warning={new FormError("I\'m a warning too...")}\n  />,\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["But when you handle errors via ",(0,s.jsx)(n.code,{children:"useDataValue"}),", you may rather provide an object with messages, which will be used to display the error:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const { error, hasError } = useDataValue({\n  required: true,\n  errorMessages: {\n    required: 'Show this when \"required\" fails!',\n  },\n  ...componentProps,\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In order to invoke an error without a change and blur event, you can use ",(0,s.jsx)(n.code,{children:"validateInitially"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const { error, hasError } = useDataValue({\n  value: undefined,\n  required: true,\n  validateInitially: true,\n  errorMessages: {\n    required: 'Show this when \"required\" fails!',\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Event handlers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleFocus()"})," to call the ",(0,s.jsx)(n.code,{children:"onFocus"})," event."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleBlur()"})," to call the ",(0,s.jsx)(n.code,{children:"onBlur"})," event."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleChange(value)"})," to call the ",(0,s.jsx)(n.code,{children:"onChange"})," event. Will update/change the internal value and re-render the React Hook, so will the outer component too."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"handleChange(value, (additionalArgs = null))\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"updateValue(value)"})," to update/change the internal value, without calling any events."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"forceUpdate()"})," to re-render the React Hook along with the outer component."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Value transformers"}),"\n",(0,s.jsx)(n.p,{children:"The transformers are hooks to transform the value on different stages."}),"\n",(0,s.jsxs)(n.p,{children:["They should return a transformed value: ",(0,s.jsx)(n.code,{children:"(value) => value"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toInput"})," transforms the value before it gets returned as the ",(0,s.jsx)(n.code,{children:"value"}),":"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fromInput"})," transforms the value given by ",(0,s.jsx)(n.code,{children:"handleChange"})," before it is used in the further process flow. Use it to destruct the value form the original event object."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toEvent"})," transforms the internal value before it gets returned by even callbacks such as ",(0,s.jsx)(n.code,{children:"onChange"}),", ",(0,s.jsx)(n.code,{children:"onFocus"})," and ",(0,s.jsx)(n.code,{children:"onBlur"}),". The second parameter returns the event type: ",(0,s.jsx)(n.code,{children:"onChange"}),", ",(0,s.jsx)(n.code,{children:"onFocus"}),", ",(0,s.jsx)(n.code,{children:"onBlur"})," or ",(0,s.jsx)(n.code,{children:"onBlurValidator"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fromExternal"})," transforms the given props ",(0,s.jsx)(n.code,{children:"value"})," before any other step gets entered."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"transformValue"})," transforms the value given by ",(0,s.jsx)(n.code,{children:"handleChange"})," after ",(0,s.jsx)(n.code,{children:"fromInput"})," and before ",(0,s.jsx)(n.code,{children:"updateValue"})," and ",(0,s.jsx)(n.code,{children:"toEvent"}),". The second parameter returns the current value"]}),"\n"]}),"\n"]})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}}}]);
//# sourceMappingURL=component---src-docs-uilib-extensions-forms-create-component-use-data-value-info-mdx-f396fe566230221ce8f7.js.map