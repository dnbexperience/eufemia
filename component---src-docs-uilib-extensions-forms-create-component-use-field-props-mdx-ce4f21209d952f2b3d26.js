"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[97811,66800,96084],{68998:function(e,n,r){r.r(n);var s=r(52322),o=r(45392),i=r(74577),l=r(96107);function t(e){return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.default,{}),"\n",(0,s.jsx)(l.default,{})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(t,e)})):t()}},96107:function(e,n,r){r.r(n),r.d(n,{default:function(){return h}});var s={};r.r(s),r.d(s,{CustomComponentExample:function(){return a}});var o=r(52322),i=r(45392),l=(r(2784),r(7325)),t=r(26409),d=r(96781);const a=()=>(0,o.jsx)(l.Z,{scope:{useFieldProps:t.Z,FieldBlock:d.Z},noInline:!0,children:"const MySliderComponent = (props) => {\n  const fromInput = React.useCallback(\n    (event) => (typeof event === 'number' ? event : event?.value || 0),\n    [],\n  )\n  const errorMessages = React.useMemo(\n    () => ({\n      required: 'This field is required',\n      ...props.errorMessages,\n    }),\n    [props.errorMessages],\n  )\n  const schema =\n    React.useMemo <\n    JSONSchema >\n    (() =>\n      props.schema ?? {\n        type: 'number',\n        minimum: props.minimum,\n        maximum: props.maximum,\n      },\n    [props.schema, props.minimum, props.maximum])\n  const preparedProps = {\n    fromInput,\n    schema,\n    ...errorMessages,\n    label: 'Label',\n    ...props,\n  }\n  const {\n    id,\n    label,\n    info,\n    warning,\n    error,\n    value,\n    width = 'medium',\n    minimum = 0,\n    maximum = 100,\n    step = 1,\n    handleChange,\n    handleFocus,\n    handleBlur,\n  } = useFieldProps(preparedProps)\n  const steps = {\n    minimum,\n    maximum,\n    step,\n  }\n  return (\n    <FieldBlock\n      forId={id}\n      label={label}\n      info={info}\n      warning={warning}\n      error={error}\n      width={width}\n    >\n      <Flex.Stack>\n        <Field.Number\n          value={value}\n          showStepControls\n          onChange={handleChange}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n          {...steps}\n        />\n        <Slider\n          id={id}\n          value={value}\n          onChange={handleChange}\n          onDragStart={handleFocus}\n          onDragEnd={handleBlur}\n          {...steps}\n        />\n      </Flex.Stack>\n    </FieldBlock>\n  )\n}\nrender(\n  <Form.Handler\n    data={{\n      sliderValue: 50,\n    }}\n  >\n    <MySliderComponent\n      path=\"/sliderValue\"\n      minimum={50}\n      maximum={80}\n      required\n      info=\"Info\"\n    />\n  </Form.Handler>,\n)\n"});function c(e){const n=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,i.ah)(),e.components);return s||u("Examples",!1),a||u("Examples.CustomComponentExample",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{children:"Demos"}),"\n",(0,o.jsx)(n.p,{children:"On the consumer side, we can use this custom component like so:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'<Form.Handler data={{ sliderValue: 50 }}>\n  <MySliderComponent\n    path="/sliderValue"\n    minimum={50}\n    maximum={80}\n    required\n    info="Info"\n  />\n</Form.Handler>\n'})}),"\n",(0,o.jsx)(a,{})]})}var h=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(c,e)})):c(e)};function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},74577:function(e,n,r){r.r(n);var s=r(52322),o=r(45392);function i(e){const n=Object.assign({h1:"h1",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",ul:"ul",li:"li",strong:"strong",a:"a",h4:"h4",ol:"ol"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"Description"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useFieldProps"})," hook standardize handling of the value flow for a single consumer component representing one data point. It holds error state, hides it while the field is in focus, connects to surrounding ",(0,s.jsx)(n.code,{children:"DataContext"})," (if present) and other things that all field or value components needs to do. By implementing custom field or value components and passing the received props through ",(0,s.jsx)(n.code,{children:"useFieldProps"}),", all these features work the same way as other field or value components, and you only need to implement the specific unique features of that component."]}),"\n",(0,s.jsx)(n.h2,{children:"How to use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useFieldProps } from '@dnb/eufemia/extensions/forms'\nconst { value } = useFieldProps(componentProps)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Advanced usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import {\n  useFieldProps,\n  useErrorMessage,\n} from '@dnb/eufemia/extensions/forms'\n\nconst sharedContext = useContext(SharedContext)\nconst tr = sharedContext?.translation.Forms\n\nconst errorMessages = useErrorMessage(props.path, props.errorMessages, {\n  // Your default error messages\n  required: tr.inputErrorRequired,\n  pattern: tr.inputErrorPattern,\n})\n\nconst preparedProps = {\n  errorMessages,\n  // Your component props\n  ...props,\n}\n\nconst {\n  // Return Parameters:\n  value,\n  onChange,\n  onFocus,\n  onBlur,\n  error,\n  hasError,\n  isChanged,\n  setHasFocus,\n  htmlAttributes,\n\n  // Component Properties\n  ...rest\n} = useFieldProps(preparedProps)\n\nrender(\n  <Input\n    value={value}\n    onChange={onChange}\n    onFocus={onFocus}\n    onBlur={onBlur}\n    {...htmlAttributes}\n  />,\n)\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Internal Properties"}),"\n",(0,s.jsx)(n.p,{children:"All properties are optional and can be used as needed. These properties can be provided as part of your component properties."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"value"})," the input value (string)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"emptyValue"})," defines what value is considered to be empty. Defaults to ",(0,s.jsx)(n.code,{children:"undefined"}),". But an empty string is also validated when required is true."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"path"})," the JSON pointer that defines the entry name/key in the data structure."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Validation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"required"})," if true, it will call ",(0,s.jsx)(n.code,{children:"validateRequired"})," for validation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"schema"})," or ",(0,s.jsx)(n.code,{children:"pattern"})," for JSON schema validation powered by ",(0,s.jsx)(n.a,{href:"https://ajv.js.org/",children:"ajv"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validator"})," your custom validation function. It will run on every keystroke. Can be an async function. Use it together with ",(0,s.jsx)(n.a,{href:"/uilib/helpers/functions/#debounce",children:"debounceAsync"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onBlurValidator"})," your custom validation function. It will run on a ",(0,s.jsx)(n.code,{children:"handleBlur()"})," call. Use it over ",(0,s.jsx)(n.code,{children:"validator"})," for validations with side-effects. Can be an async function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validateRequired"})," does allow you to provide a custom logic for how the ",(0,s.jsx)(n.code,{children:"required"})," prop should validate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validateInitially"})," in order to show an error without a change and blur event. Used for rare cases."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validateUnchanged"})," in order to validate without a change and blur event. Used for rare cases."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"continuousValidation"})," in order to validate without a focus event beforehand. Used for rare cases."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," object like ",(0,s.jsx)(n.code,{children:"FormError"})," that includes the string to display or an object with the key ",(0,s.jsx)(n.code,{children:"validationRule"}),". More info down below."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"errorMessages"})," object with your custom messages, where each key represents a ",(0,s.jsx)(n.code,{children:"validationRule"}),". More info down below."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Return Parameters"}),"\n",(0,s.jsx)(n.p,{children:"It returns all of the given component properties, in addition to these:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"value"})," the output value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"})," creates a memorized id."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dataContext"})," the internal shared data context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," the error object, in case an error is invoked. Will skip returning the error object, if the hook is used in a nested ",(0,s.jsx)(n.a,{href:"/uilib/extensions/forms/create-component/FieldBlock/",children:"FieldBlock"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hasError"})," will return true in case of an error, even if the hook is nested in a ",(0,s.jsx)(n.code,{children:"FieldBlock"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"htmlAttributes"})," object that include needed HTML (e.g. aria-_ or data-_) attributes, ready to be spread on form elements."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isChanged"})," returns ",(0,s.jsx)(n.code,{children:"true"})," if the value has changed with e.g. ",(0,s.jsx)(n.code,{children:"handleChange"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"setHasFocus"})," accepts a boolean as value. When called, it will update the internal logic - for event handling and validation. Will re-render the React Hook and its outer component."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onFocus"})," event handler to assign to a form element."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onBlur"})," event handler to assign to a form element."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onChange"})," event handler to assign to a form element. When an ",(0,s.jsx)(n.code,{children:"async"})," function is used, it will set the ",(0,s.jsx)(n.code,{children:"fieldState"})," to pending. The corresponding ",(0,s.jsx)(n.a,{href:"/uilib/extensions/forms/create-component/FieldBlock/",children:"FieldBlock"})," will show an indicator on the field label."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Custom validateRequired"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const validateRequired = (\n  value: Value,\n  { emptyValue, required, isChanged },\n) => {\n  return required && value === emptyValue\n    ? new FormError('The value is required', {\n        validationRule: 'required',\n      })\n    : undefined\n}\n\nconst { error, hasError } = useFieldProps({\n  value: undefined,\n  required: true,\n  validateInitially: true,\n  validateRequired,\n  errorMessages: {\n    required: 'Show this when \"required\" fails!',\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Validation order"}),"\n",(0,s.jsx)(n.p,{children:"During validation, the different APIs do have a prioritization order and will stop processing further when they match:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"required"})," prop"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"schema"})," prop (including ",(0,s.jsx)(n.code,{children:"pattern"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"validator"})," prop"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Error handling"}),"\n",(0,s.jsx)(n.p,{children:"Validation and error-handling are tightly coupled together. When a validation fails, you may use the error-object to handle and show the failures/statuses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"render(\n  <Field.String\n    label=\"Label\"\n    error={new Error('This is what is wrong...')}\n  />,\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["But when you handle errors via ",(0,s.jsx)(n.code,{children:"useFieldProps"}),", you may rather provide an object with messages, which will be used to display the error:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const { error, hasError } = useFieldProps({\n  required: true,\n  errorMessages: {\n    required: 'Show this when \"required\" fails!',\n  },\n  ...componentProps,\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To re-use existing ",(0,s.jsx)(n.code,{children:"errorMessages"}),", you can use the ",(0,s.jsx)(n.code,{children:"FormError"})," constructor as well:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { FormError } from '@dnb/eufemia/extensions/forms'\n\n// Will show the message from the errorMessages\nnew FormError('Internal error message', {\n  validationRule: 'required',\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In order to invoke an error without a change and blur event, you can use ",(0,s.jsx)(n.code,{children:"validateInitially"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const { error, hasError } = useFieldProps({\n  value: undefined,\n  required: true,\n  validateInitially: true,\n  errorMessages: {\n    required: 'Show this when \"required\" fails!',\n  },\n})\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Event handlers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleFocus()"})," to call the ",(0,s.jsx)(n.code,{children:"onFocus"})," event."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleBlur()"})," to call the ",(0,s.jsx)(n.code,{children:"onBlur"})," event."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleChange(value)"})," to call the ",(0,s.jsx)(n.code,{children:"onChange"})," event. Will update/change the internal value and re-render the React Hook, so will the outer component too."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"handleChange(value, (additionalArgs = null))\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"updateValue(value)"})," to update/change the internal value, without calling any events."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"forceUpdate()"})," to re-render the React Hook along with the outer component."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Value transformers"}),"\n",(0,s.jsx)(n.p,{children:"The transformers are hooks to transform the value on different stages."}),"\n",(0,s.jsxs)(n.p,{children:["They should return a transformed value: ",(0,s.jsx)(n.code,{children:"(value) => value"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toInput"})," transforms the value before it gets returned as the ",(0,s.jsx)(n.code,{children:"value"}),":"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fromInput"})," transforms the value given by ",(0,s.jsx)(n.code,{children:"handleChange"})," before it is used in the further process flow. Use it to destruct the value form the original event object."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toEvent"})," transforms the internal value before it gets returned by even callbacks such as ",(0,s.jsx)(n.code,{children:"onChange"}),", ",(0,s.jsx)(n.code,{children:"onFocus"})," and ",(0,s.jsx)(n.code,{children:"onBlur"}),". The second parameter returns the event type: ",(0,s.jsx)(n.code,{children:"onChange"}),", ",(0,s.jsx)(n.code,{children:"onFocus"}),", ",(0,s.jsx)(n.code,{children:"onBlur"})," or ",(0,s.jsx)(n.code,{children:"onBlurValidator"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fromExternal"})," transforms the given props ",(0,s.jsx)(n.code,{children:"value"})," before any other step gets entered."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"transformValue"})," transforms the value given by ",(0,s.jsx)(n.code,{children:"handleChange"})," after ",(0,s.jsx)(n.code,{children:"fromInput"})," and before ",(0,s.jsx)(n.code,{children:"updateValue"})," and ",(0,s.jsx)(n.code,{children:"toEvent"}),". The second parameter returns the current value"]}),"\n"]}),"\n"]})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}}}]);
//# sourceMappingURL=component---src-docs-uilib-extensions-forms-create-component-use-field-props-mdx-ce4f21209d952f2b3d26.js.map