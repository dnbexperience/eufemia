"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[12575,44592],{85396:function(e,t,n){n.r(t);var a=n(52322),i=n(45392),s=n(45406);function r(e){const t=Object.assign({h1:"h1",p:"p",code:"code",a:"a",pre:"pre",h2:"h2",h3:"h3"},(0,i.a)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{children:"DataContext"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"DataContext"})," builds a surrounding ",(0,a.jsx)(t.a,{href:"https://react.dev/learn/passing-data-deeply-with-context",children:"React context"})," that binds an entire source dataset together with the fields placed within. It enables fields and other components to retrieve data from the source data using ",(0,a.jsx)(t.code,{children:"path"})," parameters that identify where in the source data the target value is located, and the same components will report changes to the data back so the context can update the dataset."]}),"\n",(0,a.jsxs)(t.p,{children:["Example of using the ",(0,a.jsx)(t.code,{children:"DataContext.Provider"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'<DataContext.Provider data={data} onChange={handleChange}>\n  <Field.String path="/firstName" />\n</DataContext.Provider>\n'})}),"\n",(0,a.jsxs)(t.p,{children:["For a more complete feature set tailored to building forms, please use ",(0,a.jsx)(t.a,{href:"/uilib/extensions/forms/Form/Handler",children:"Form.Handler"}),". It uses DataContext internally."]}),"\n",(0,a.jsx)(t.h2,{children:"Components"}),"\n",(0,a.jsx)(s.default,{}),"\n",(0,a.jsx)(t.h2,{children:"More details"}),"\n",(0,a.jsxs)(t.p,{children:["If you don't want to repeat all the logic that drills down to values in the source data, and ensure that changes are sent to the right place, you can surround the components with a ",(0,a.jsx)(t.a,{href:"/uilib/extensions/forms/DataContext/Provider",children:"DataContext.Provider"})," component. This means that you feed the form with source data in one place, and give it only one ",(0,a.jsx)(t.code,{children:"onChange"})," callback. Then you only send the individual fields instructions about where in the data set the value that field is to process is located. The components then communicate internally and ensure that the values are retrieved and sent to the correct location."]}),"\n",(0,a.jsxs)(t.p,{children:["The reference to a specific field's value in the dataset is given with a property called ",(0,a.jsx)(t.code,{children:"path"}),". Paths are defined in a syntax called JSON Pointer, which is basically a slash-separated string that can go several levels, and consist of both object-properties and array indexes. Examples of paths are: ",(0,a.jsx)(t.code,{children:"/firstName"}),", ",(0,a.jsx)(t.code,{children:"/nested/path/to/value"})," and ",(0,a.jsx)(t.code,{children:"/list/2/keyInThirdObject"}),". More information about JSON Pointers can be found on ",(0,a.jsx)(t.a,{href:"https://json-schema.org/draft/2020-12/relative-json-pointer.html",children:"the website of JSON Schema"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"In practice, this means that you can go from:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"const handleChange = useCallback((path, value) => {\n  // Update external state\n})\n\nreturn (\n  <div id=\"my-form\">\n    <Field.String\n      value={data.firstName}\n      onChange={(value) => handleChange('firstName', value)}\n    />\n    <Field.String\n      value={data.lastName}\n      onChange={(value) => handleChange('lastName', value)}\n    />\n    <Field.Email\n      value={data.email}\n      onChange={(value) => handleChange('email', value)}\n    />\n    <Field.String\n      label=\"Special non-standardized value\"\n      value={data.specialValue}\n      onChange={(value) => handleChange('specialValue', value)}\n    />\n  </div>\n)\n"})}),"\n",(0,a.jsx)(t.p,{children:"to:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'const handleChange = useCallback((path, value) => {\n  // Update external state\n})\n\nreturn (\n  <DataContext.Provider data={data} onChange={handleChange}>\n    <Field.String path="/firstName" />\n    <Field.String path="/lastName" />\n    <Field.Email path="/email" />\n    <Field.String\n      path="/specialValue"\n      label="Special non-standardized value"\n    />\n  </DataContext.Provider>\n)\n'})}),"\n",(0,a.jsx)(t.p,{children:"This abstracts away some logic that many are used to having available for debugging and adjustments, which can be unfamiliar and difficult to get used to. The goal of the way this is designed is for it to be well tested and predictable, so that you don't need to have this boilerplate logic available. In addition, properties from the individual components make them flexible in use, and this can be continuously expanded to cover recurring needs from implementations."}),"\n",(0,a.jsx)(t.h3,{children:"Error handling"}),"\n",(0,a.jsxs)(t.p,{children:["Besides how the forms are built up and the link to the surrounding data flow, these form components must ensure that the user experience is as much as possible in line with the way we have defined that it should work in practice. An example of this is when the error messages appear on the screen. Both the individual input component and any surrounding ",(0,a.jsx)(t.code,{children:"DataContext.Provider"})," component hold an internal state that says whether the value in the field has an error or not. In addition, it has a separate state that states whether error messages should be displayed or not."]}),"\n",(0,a.jsxs)(t.p,{children:["An example of what this leads to is when a field has an invalid value, for example because the field starts empty but is required. Or if the field requires a given syntax (such as national identity number), then the error message is not displayed before or at the same time as the user fills in the field in question. However, when the user jumps out of the field, the error message will appear if the value is still not valid based on the validation properties the component has received. When the user then starts to adjust the field in question, the error message is hidden again until they jump out of the field. In addition, a surrounding ",(0,a.jsx)(t.code,{children:"DataContext.Provider"})," will check all the fields for errors, so that you do not get to the next step in a step-divided form, or can send the form and trigger ",(0,a.jsx)(t.code,{children:"onSubmit"})," if there are still fields on the screen that have errors."]}),"\n",(0,a.jsxs)(t.p,{children:["In the case of forms divided into several wizard steps, the combination of the components ",(0,a.jsx)(t.code,{children:"DataContext.Provider"})," and ",(0,a.jsx)(t.code,{children:"Wizard.Step"})," will also ensure that only the fields that are visible on the screen (for the relevant step, or based on what is hidden or shown via the Visibility component) provide a basis for whether one can proceed in the process or not."]}),"\n",(0,a.jsx)(t.h3,{children:"Hierarchically overridable properties"}),"\n",(0,a.jsxs)(t.p,{children:["Configuration of the form functionality through properties for all components can be hierarchically overridden. This means that the further into the component structure you get, the higher priority properties have. For example, a component that is given a ",(0,a.jsx)(t.code,{children:"path"})," to retrieve data from the ",(0,a.jsx)(t.code,{children:"DataContext.Provider"})," will rather prioritize a ",(0,a.jsx)(t.code,{children:"value"})," property that the component receives directly if both parts are available:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"<DataContext.Provider data={{ foo: 'I am the chosen one!' }}>\n  <Value.String path=\"/foo\" />\n</DataContext.Provider>\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'<DataContext.Provider data={{ foo: \'I am not chosen :-(\' }}>\n  <Value.String path="/foo" value="I am the one!" />\n</DataContext.Provider>\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the same way, components that have text properties built in, such as field label and error message for required field on ",(0,a.jsx)(t.code,{children:"Field.Email"}),", will choose what it receives instead of the default values if both are available:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"<Field.Email />\n// Gets the default label, and the email-pattern validation.\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'<Field.Email label="Send me e-mail on this address" />\n// Gets the custom label, but still the default email-pattern validation.\n'})})]})}t.default=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.a)(),e.components);return t?(0,a.jsx)(t,Object.assign({},e,{children:(0,a.jsx)(r,e)})):r(e)}},45406:function(e,t,n){n.r(t),n.d(t,{default:function(){return r}});var a=n(68270),i=n(77491),s=n(52322);function r(e){const{allMdx:{edges:t}}=(0,a.useStaticQuery)("3299673601");return(0,s.jsx)(i.Z,{edges:t,...e})}},77491:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(2784),i=n(42351),s=n(65359),r=n(43095),o=n(79254),l=n(68514),d=n(34262),h=n(595),c=n(52322);function u(e){let{edges:t,level:n,size:u,description:p=null,returnListItems:m=!1,...f}=e;const x=m?i.Z:a.Fragment,g=m?s.Z:a.Fragment;(0,l.TW)(n||2);const v=t.map(((e,t)=>{let{node:{frontmatter:{title:a,description:i},fields:{slug:s}}}=e;return(0,c.jsxs)(g,{children:[(0,c.jsx)(l,{}),(0,c.jsx)(x,{})]},t);function l(){const e=(0,c.jsx)(o.Z,{href:"/"+s,children:a});return m?e:(0,c.jsx)(r.Z,{level:n||2,size:u,useSlug:"/"+s,title:a,...f,children:e})}function x(){const e=null!==p?p:i;if(e)return m?(0,c.jsxs)(c.Fragment,{children:[":"," ",(0,c.jsx)(d.D,{components:h.L,disallowedElements:["p"],unwrapDisallowed:!0,children:e})]}):(0,c.jsx)(d.D,{components:h.L,children:e})}}));return(0,c.jsx)(x,{children:v})}}}]);
//# sourceMappingURL=component---src-docs-uilib-extensions-forms-data-context-mdx-70612b2da2668998aac1.js.map