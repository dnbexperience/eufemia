"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[42874,78981,27263,54859],{84399:function(e,n,t){t.r(n);var s=t(52322),o=t(45392),i=t(95034),a=t(60583),r=t(31019);function l(e){const n=Object.assign({h1:"h1",p:"p",pre:"pre",code:"code",strong:"strong",ul:"ul",li:"li",a:"a",h2:"h2",h3:"h3"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"About fields"}),"\n",(0,s.jsx)(n.p,{children:"Both the naming and the way the components work are based on being data-driven."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { Field } from '@dnb/eufemia/extensions/forms'\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Table of Contents"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#categorized-base-components",children:"Categorized base components"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#all-base-components",children:"All base components"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#feature-fields",children:"Feature fields"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#more-info",children:"More info"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#standardized-properties",children:"Standardized properties"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#controlled--uncontrolled",children:"Controlled & Uncontrolled"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#creating-custom-field-components",children:"Creating custom field components"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Categorized base components"}),"\n",(0,s.jsx)(n.p,{children:"The base components exists of several kinds, such as the:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"input category"})," – which contains of field types that accept and produce values based on input from the user, such as text and numbers.","\n",(0,s.jsx)(i.default,{}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"selection category"})," – which contains of field types that allow the user to choose between a fixed set of values (options) represented by different UI components:","\n",(0,s.jsx)(a.default,{}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"toggle category"})," – which contains of field types that allow the user to toggle between two values, such as ",(0,s.jsx)(n.code,{children:"true"})," and ",(0,s.jsx)(n.code,{children:"false"}),":","\n",(0,s.jsx)(r.default,{}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Feature components"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/uilib/extensions/forms/feature-fields/",children:"Feature fields"})," builds on top of the base components to add more specific features targeting a given type of data."]}),"\n",(0,s.jsx)(n.h2,{children:"More info"}),"\n",(0,s.jsx)(n.h3,{children:"Standardized properties"}),"\n",(0,s.jsxs)(n.p,{children:["All input component has a fixed set of props that make it possible to build more complex standardized functionality around them. The most important ones here are ",(0,s.jsx)(n.code,{children:"value"})," and ",(0,s.jsx)(n.code,{children:"onChange"}),". Value expects values in the given data type, so for example ",(0,s.jsx)(n.code,{children:"Field.Number"})," expects a ",(0,s.jsx)(n.code,{children:"value"})," of the type ",(0,s.jsx)(n.code,{children:"number"}),", and will give a type error in Typescript if it e.g. receives a number in a ",(0,s.jsx)(n.code,{children:"string"}),". The callback function submitted to ",(0,s.jsx)(n.code,{children:"onChange"})," will always receive the value of the corresponding type as the first argument."]}),"\n",(0,s.jsxs)(n.p,{children:["It is deliberate that ",(0,s.jsx)(n.code,{children:"onChange"})," sends out the value from the field, and not the event object that comes from the actual HTML tag into which the user enters data. This is to create a less tight coupling between application code that uses the components, and the internal implementation in the field components. In addition, this makes the surrounding logic simpler by not having to extract, for example, ",(0,s.jsx)(n.code,{children:"e.target.value"})," everywhere."]}),"\n",(0,s.jsxs)(n.p,{children:["The basic components have a number of properties that make it possible to control how they function in the interface, such as ",(0,s.jsx)(n.code,{children:"multiline"})," on ",(0,s.jsx)(n.code,{children:"Field.String"}),", which chooses whether to get one line of text (input tag) or several lines (textarea tag) . In addition, they have a number of validation props, such as ",(0,s.jsx)(n.code,{children:"minLength"})," and ",(0,s.jsx)(n.code,{children:"required"}),"."]}),"\n",(0,s.jsx)(n.h3,{children:"Controlled & Uncontrolled"}),"\n",(0,s.jsxs)(n.p,{children:['In React, it\'s important to be aware of where the states of a given set of data "lives". This can be an entire object that represents an entity the user is going to make changes to (e.g. a user or a bank account), but it also applies to the individual value a form makes changes to. A form field can be ',(0,s.jsx)(n.a,{href:"https://reactjs.org/docs/forms.html#controlled-components",children:"controlled"})," or ",(0,s.jsx)(n.a,{href:"https://reactjs.org/docs/uncontrolled-components.html",children:"uncontrolled"}),". The components in this package make it possible to work in both ways."]}),"\n",(0,s.jsxs)(n.p,{children:["If the functionality is designed so that the state of the data will live outside the form components, you give the components a ",(0,s.jsx)(n.code,{children:"value"})," and an ",(0,s.jsx)(n.code,{children:"onChange"}),", and ensure that all changes that are sent out via ",(0,s.jsx)(n.code,{children:"onChange"})," are fed back via ",(0,s.jsx)(n.code,{children:"value"})," so that it functions as a controlled component. The internal logic in the components will then ensure that the value is kept the same via the changes it receives from the outside."]}),"\n",(0,s.jsxs)(n.p,{children:["If you want the state of the value to live inside the input component, do not send the updated value in via ",(0,s.jsx)(n.code,{children:"value"}),". The logic will then keep the internal value with the changes continuously, and still send the latest version with all the changes the user has made, even if they are not received continuously via ",(0,s.jsx)(n.code,{children:"value"}),", as a basic ",(0,s.jsx)(n.code,{children:"<input>"})," tag in React expects."]}),"\n",(0,s.jsx)(n.h3,{children:"Creating custom field components"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useDataValue"})," hook that is used in all existing field components is exported to make it possible to create custom field components that have the same properties and follow the same flow as the standard components, without the need to recreate all the basic state handling features."]})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}},95034:function(e,n,t){t.r(n),t.d(n,{default:function(){return a}});var s=t(68270),o=t(75440),i=t(52322);function a(){const{allMdx:{edges:e}}=(0,s.useStaticQuery)("3527086586");return(0,i.jsx)(o.Z,{space:{top:"x-small"},level:3,description:"",edges:e})}},60583:function(e,n,t){t.r(n),t.d(n,{default:function(){return a}});var s=t(68270),o=t(75440),i=t(52322);function a(){const{allMdx:{edges:e}}=(0,s.useStaticQuery)("2488855444");return(0,i.jsx)(o.Z,{space:{top:"x-small"},level:3,description:"",edges:e})}},31019:function(e,n,t){t.r(n),t.d(n,{default:function(){return a}});var s=t(68270),o=t(75440),i=t(52322);function a(){const{allMdx:{edges:e}}=(0,s.useStaticQuery)("2421328184");return(0,i.jsx)(o.Z,{space:{top:"x-small"},level:3,description:"",edges:e})}}}]);
//# sourceMappingURL=component---src-docs-uilib-extensions-forms-fields-mdx-d998496aa8a6f4213582.js.map