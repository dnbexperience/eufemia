"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[3123],{55838:function(e,n,t){t.r(n),t.d(n,{default:function(){return y}});var i={};t.r(i),t.d(i,{BasedOnBooleanTrue:function(){return h},BasedOnContext:function(){return m},BooleanExample:function(){return u},FilterData:function(){return f},InferData:function(){return c},InheritVisibility:function(){return b},NestedExample:function(){return p},PathValue:function(){return d},VisibilityOnValidation:function(){return x}});var r=t(52322),l=t(45392),a=(t(2784),t(46832)),o=t(99210),s=t(4902);const u=()=>(0,r.jsx)(a.Z,{scope:{TestElement:o.Z},children:'<Form.Handler>\n  <Flex.Stack>\n    <Field.Boolean\n      label="Show content"\n      variant="buttons"\n      path="/toggleValue"\n      value={false}\n    />\n    <Form.Visibility pathTrue="/toggleValue" animate>\n      <TestElement>Item 1</TestElement>\n      <TestElement>Item 2</TestElement>\n    </Form.Visibility>\n  </Flex.Stack>\n</Form.Handler>\n'}),d=()=>(0,r.jsx)(a.Z,{children:'<Form.Handler>\n  <Field.Toggle\n    label="Show content"\n    valueOn="checked"\n    valueOff="unchecked"\n    variant="buttons"\n    path="/toggleValue"\n    value="unchecked"\n  />\n  <Form.Visibility\n    visibleWhen={{\n      path: \'/toggleValue\',\n      hasValue: \'checked\',\n    }}\n    animate\n  >\n    <P>This is visible</P>\n  </Form.Visibility>\n</Form.Handler>\n'}),c=()=>(0,r.jsx)(a.Z,{noInline:!0,children:'const MyComponent = () => {\n  const { data } = Form.useData(\'example-form\', {\n    toggleValue: false,\n  })\n  const inferDataFunc = React.useCallback(\n    () => data.toggleValue,\n    [data.toggleValue],\n  )\n  return (\n    <Form.Handler id="example-form">\n      <Flex.Stack>\n        <Field.Boolean path="/toggleValue" label="Check me" />\n        <Form.Visibility inferData={inferDataFunc} animate>\n          <P>This is visible</P>\n        </Form.Visibility>\n      </Flex.Stack>\n    </Form.Handler>\n  )\n}\nrender(<MyComponent />)\n'}),h=()=>(0,r.jsx)(a.Z,{children:"<Form.Visibility visible={true}>\n  <P>This is visible</P>\n</Form.Visibility>\n"}),m=()=>(0,r.jsx)(a.Z,{children:'<Form.Handler\n  data={{\n    toBe: true,\n    notToBe: false,\n  }}\n>\n  <Form.Visibility pathTrue="/toBe">\n    <P>This will show, as long as `toBe` is true.</P>\n  </Form.Visibility>\n  <Form.Visibility pathTrue="/notToBe">\n    <P>This will not show until `notToBe` is true.</P>\n  </Form.Visibility>\n</Form.Handler>\n'}),p=()=>(0,r.jsx)(a.Z,{scope:{Tools:s},noInline:!0,children:'const filterDataHandler = ({ props }) => !props[\'data-exclude-field\']\nconst MyForm = () => {\n  return (\n    <Form.Handler\n      defaultData={{\n        isVisible: false,\n      }}\n    >\n      <Flex.Stack>\n        <Field.Boolean\n          label="Visible"\n          variant="button"\n          path="/isVisible"\n          data-exclude-field\n        />\n        <Form.Visibility\n          pathTrue="/isVisible"\n          animate\n          keepInDOM\n          fieldPropsWhenHidden={{\n            \'data-exclude-field\': true,\n          }}\n        >\n          <Field.Selection\n            label="Choose"\n            variant="radio"\n            value="less"\n            path="/mySelection"\n          >\n            <Field.Option value="less" title="Less" />\n            <Field.Option value="more" title="More" />\n          </Field.Selection>\n\n          <Form.Visibility\n            visibleWhen={{\n              path: \'/mySelection\',\n              hasValue: \'more\',\n            }}\n            animate\n            keepInDOM\n            fieldPropsWhenHidden={{\n              \'data-exclude-field\': true,\n            }}\n          >\n            <Field.String label="My String" path="/myString" value="foo" />\n          </Form.Visibility>\n        </Form.Visibility>\n      </Flex.Stack>\n\n      <Output />\n    </Form.Handler>\n  )\n}\nconst Output = () => {\n  const { filterData } = Form.useData()\n  const filteredData = filterData(filterDataHandler)\n  return <Tools.Log data={filteredData} top />\n}\nrender(<MyForm />)\n'}),f=()=>(0,r.jsx)(a.Z,{scope:{Tools:s},noInline:!0,children:'const filterDataPaths = {\n  \'/isVisible\': false,\n  \'/mySelection\': ({ data }) => data.isVisible,\n  \'/myString\': ({ data }) => {\n    return data.isVisible && data.mySelection === \'more\'\n  },\n}\nconst MyForm = () => {\n  return (\n    <Form.Handler\n      defaultData={{\n        myString: \'foo\',\n      }}\n    >\n      <Flex.Stack>\n        <Field.Boolean\n          label="Visible"\n          variant="button"\n          path="/isVisible"\n          defaultValue={false}\n        />\n        <Form.Visibility pathTrue="/isVisible" animate>\n          <Field.Selection\n            label="Choose"\n            variant="radio"\n            value="less"\n            path="/mySelection"\n          >\n            <Field.Option value="less" title="Less" />\n            <Field.Option value="more" title="More" />\n          </Field.Selection>\n\n          <Form.Visibility\n            visibleWhen={{\n              path: \'/mySelection\',\n              hasValue: \'more\',\n            }}\n            animate\n          >\n            <Field.String label="My String" path="/myString" />\n          </Form.Visibility>\n        </Form.Visibility>\n\n        <Form.Visibility\n          pathDefined="/myString"\n          filterData={filterDataPaths}\n          animate\n        >\n          <Form.Card>\n            <P>\n              Result: <Value.String path="/myString" inline />\n            </P>\n          </Form.Card>\n        </Form.Visibility>\n      </Flex.Stack>\n\n      <Output />\n    </Form.Handler>\n  )\n}\nconst Output = () => {\n  const { filterData } = Form.useData()\n  const filteredData = filterData(filterDataPaths)\n  return <Tools.Log data={filteredData} top />\n}\nrender(<MyForm />)\n'});function b(){return(0,r.jsx)(a.Z,{children:'<Form.Handler>\n  <Form.Card>\n    <Field.Boolean\n      variant="button"\n      path="/isVisible"\n      defaultValue={true}\n    />\n\n    <Form.Visibility pathTrue="/isVisible" animate>\n      <Field.Name.First path="/foo" defaultValue="foo" />\n      <Field.Name.Last path="/bar" defaultValue="bar" />\n    </Form.Visibility>\n\n    <Value.Provider inheritVisibility>\n      <HeightAnimation>\n        <Value.SummaryList>\n          <Value.Name.First path="/foo" />\n          <Value.Name.First path="/bar" />\n        </Value.SummaryList>\n      </HeightAnimation>\n    </Value.Provider>\n  </Form.Card>\n</Form.Handler>\n'})}function x(){return(0,r.jsx)(a.Z,{children:'<Form.Handler>\n  <Form.Card>\n    <Field.Name.First path="/foo" required />\n\n    <Form.Visibility\n      visibleWhen={{\n        path: \'/foo\',\n        isValid: true,\n      }}\n      animate\n    >\n      <Value.Name.First path="/foo" />\n    </Form.Visibility>\n  </Form.Card>\n</Form.Handler>\n'})}function F(e){const n=Object.assign({h2:"h2",h3:"h3",p:"p",code:"code",pre:"pre",strong:"strong"},(0,l.ah)(),e.components);return i||V("Examples",!1),h||V("Examples.BasedOnBooleanTrue",!0),m||V("Examples.BasedOnContext",!0),u||V("Examples.BooleanExample",!0),f||V("Examples.FilterData",!0),c||V("Examples.InferData",!0),b||V("Examples.InheritVisibility",!0),p||V("Examples.NestedExample",!0),d||V("Examples.PathValue",!0),x||V("Examples.VisibilityOnValidation",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{children:"Demos"}),"\n",(0,r.jsx)(n.h3,{children:"Boolean example"}),"\n",(0,r.jsx)(u,{}),"\n",(0,r.jsx)(n.h3,{children:"Matching value"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"visibleWhen"})," is pretty powerful. You can use it to show/hide based on the value of a ",(0,r.jsx)(n.code,{children:"path"}),". You can also give it a ",(0,r.jsx)(n.code,{children:"hasValue"})," function that gives you the current value, so you can assert it and return a boolean based on that."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"<Form.Visibility\n  visibleWhen={{\n    path: '/toggleValue',\n    hasValue: (value) => value === 'checked',\n  }}\n>\n  Content\n</Form.Visibility>\n"})}),"\n",(0,r.jsx)(d,{}),"\n",(0,r.jsx)(n.h3,{children:"Direct properties"}),"\n",(0,r.jsx)(h,{}),"\n",(0,r.jsx)(n.h3,{children:"Based on DataContext"}),"\n",(0,r.jsx)(m,{}),"\n",(0,r.jsx)(n.h3,{children:"InferData"}),"\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h3,{children:"Nested visibility example"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"fieldPropsWhenHidden"})," and ",(0,r.jsx)(n.code,{children:"keepInDOM"})," to keep the content in the DOM, even if it's not visible."]}),"\n",(0,r.jsxs)(n.p,{children:["In this example we filter out all fields that have the ",(0,r.jsx)(n.code,{children:"data-exclude-field"})," attribute. See the console output for the result."]}),"\n",(0,r.jsx)(p,{}),"\n",(0,r.jsx)(n.h3,{children:"Filter data"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," This example uses ",(0,r.jsx)(n.code,{children:"filterData"})," with ",(0,r.jsx)(n.code,{children:"pathDefined"})," on a Visibility component along, which is a declarative way to describe the data to be shown."]}),"\n",(0,r.jsx)(f,{}),"\n",(0,r.jsx)(n.h3,{children:"Inherit visibility"}),"\n",(0,r.jsx)(b,{}),"\n",(0,r.jsx)(n.h3,{children:"Show children when field has no errors (validation)"}),"\n",(0,r.jsx)(x,{})]})}var y=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(F,e)})):F(e)};function V(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},38734:function(e,n,t){t.d(n,{Z:function(){return s}});var i=t(84616),r=t(2784),l=t(2394),a=t(21068);const o=["minLength","maxLength","pattern","description","min","max","multipleOf","exclusiveMinimum","exclusiveMaximum"];function s(e){const{generateRef:n,filterData:t,log:s,children:u}=e||{},{fieldPropsRef:d,valuePropsRef:c,data:h,hasContext:m}=(0,r.useContext)(a.Z),p=(0,r.useRef)({});p.current=h;const f=(0,r.useCallback)((()=>{const e=Object.entries((null==d?void 0:d.current)||{}).reduce(((e,n)=>{let[r,a]=n;if(r.startsWith("/")){const n=r.substring(1),s=n.split("/"),u=s.length,d={type:a.valueType||"string"};for(const e of o)a[e]&&(d[e]=a[e]);if(u>1){const n=[""];for(const r of s){n.push(r);const o=n.join("/properties/"),u=n.length-1===s.length,c=l.e$(e,o)?l.U2(e,o):null,h=u?d:c;if(u)!1!==(null==t?void 0:t[o])&&l.t8(e,o,h);else{const n={type:"object",...c},r=[];a.required&&r.push(s.at(-1)),null!=c&&c.required&&r.push.apply(r,(0,i.Z)(c.required)),r.length>0&&(n.required=r),!1!==(null==t?void 0:t[o])&&l.t8(e,o,n)}}}else!1!==(null==t?void 0:t[r])&&l.t8(e.properties,r,d),a.required&&e.required.push(n)}return e}),{type:"object",properties:{},required:[]}),n=Object.entries((null==d?void 0:d.current)||{}).reduce(((e,n)=>{let[t,i]=n;if(t.startsWith("/")){const n={};for(const e in i)void 0!==i[e]&&"function"!=typeof i[e]&&(n[e]=i[e]);l.t8(e,t,n)}return e}),{}),r=Object.entries((null==c?void 0:c.current)||{}).reduce(((e,n)=>{let[t,i]=n;if(t.startsWith("/")){const n={};for(const e in i)void 0!==i[e]&&"function"!=typeof i[e]&&(n[e]=i[e]);l.t8(e,t,n)}return e}),{});return 0===e.required.length&&delete e.required,{schema:e,data:p.current,propsOfFields:n,propsOfValues:r}}),[d,t,c]);return m&&(s&&console.log(f().schema),n&&(n.current=f)),u}},10454:function(e,n,t){t.d(n,{Z:function(){return a}});var i=t(2784),r=t(2394),l=t(21068);function a(e){const{log:n,generateRef:t,filterData:a,children:o}=e||{},{fieldPropsRef:s,valuePropsRef:u,data:d,hasContext:c}=(0,i.useContext)(l.Z);(0,i.useRef)({}).current=d;const h=(0,i.useCallback)((()=>{const e=Object.entries((null==s?void 0:s.current)||{}).reduce(((e,n)=>{let[t,l]=n;if(t.startsWith("/")){const n={};for(const e in l)void 0===l[e]||"function"==typeof l[e]||(0,i.isValidElement)(l[e])||(n[e]=l[e]);!1!==(null==a?void 0:a[t])&&r.t8(e,t,n)}return e}),{}),n=Object.entries((null==u?void 0:u.current)||{}).reduce(((e,n)=>{let[t,l]=n;if(t.startsWith("/")){const n={};for(const e in l)void 0===l[e]||"function"==typeof l[e]||(0,i.isValidElement)(l[e])||(n[e]=l[e]);!1!==(null==a?void 0:a[t])&&r.t8(e,t,n)}return e}),{});return{propsOfFields:e,propsOfValues:n}}),[s,a,u]);return c&&(n&&console.log(h()),t&&(t.current=h)),o}},90584:function(e,n,t){var i=t(2784),r=t(21068),l=t(4408),a=t(9149),o=t(52322);function s(e){let{placeholder:n,label:t,data:s,...d}=e;const{data:c}=(0,i.useContext)(r.Z);return(0,o.jsxs)(l.Z,{element:"output",backgroundColor:"sand-yellow",style:{maxWidth:"80vw"},innerSpace:!0,...d,children:[t&&(0,o.jsx)(a.Z,{bottom:!0,children:(0,o.jsx)("b",{children:t})}),(0,o.jsxs)("pre",{children:[n&&0===Object.keys((null!=s?s:c)||{}).length?n:JSON.stringify(u(null!=s?s:c),null,2),"Â "]})]})}function u(e,n){return void 0===n&&(n="undefined"),void 0===e?n:Array.isArray(e)?e.map((e=>u(e,n))):e&&"object"==typeof e&&e!==n?{...e,...Object.fromEntries(Object.entries(e).map((e=>{let[t,i]=e;return[t,u(i,n)]})))}:e}s._supportsSpacingProps=!0,n.Z=s},4902:function(e,n,t){t.r(n),t.d(n,{GenerateSchema:function(){return i.Z},ListAllProps:function(){return r.Z},Log:function(){return l.Z}});var i=t(38734),r=t(10454),l=t(90584)},99210:function(e,n,t){t.d(n,{Z:function(){return o}});var i=t(72779),r=t.n(i),l=t(80215),a=t(52322);function o(e){let{className:n=null,...t}=e;return(0,a.jsx)(l.Z,{className:r()("dnb-forms-test-element",n),...t})}o._supportsSpacingProps=!0}}]);
//# sourceMappingURL=component---src-docs-uilib-extensions-forms-form-visibility-demos-mdx-b7629b5316b81e9cd72a.js.map