"use strict";(self.webpackChunkdnb_design_system_portal=self.webpackChunkdnb_design_system_portal||[]).push([[9429],{63505:function(e,n,t){t.r(n);var o=t(31085),s=t(71184);function r(e){const n=Object.assign({h1:"h1",h2:"h2",p:"p",ul:"ul",li:"li",a:"a",strong:"strong",code:"code",h3:"h3",ol:"ol",em:"em",pre:"pre"},(0,s.R)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{children:"JavaScript and JSX"}),"\n",(0,o.jsx)(n.h2,{children:"Clean Code"}),"\n",(0,o.jsx)(n.p,{children:"Writing clean and readable code will ultimately benefit the end user by having better UX, because you as a developer can focus on what matters, the UI, and not spending unnecessary time on unclean code. Therefore we strongly recommend:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["following the ",(0,o.jsxs)(n.a,{href:"https://github.com/ryanmcdermott/clean-code-javascript",children:[(0,o.jsx)(n.strong,{children:"Clean Code JavaScript"})," principles"]})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"NB:"})," Even they list ",(0,o.jsx)(n.code,{children:"moment"})," as a date formatting tool, consider ",(0,o.jsx)(n.a,{href:"https://date-fns.org",children:"date-fns"})," because it has a couple of advantages over moment."]}),"\n",(0,o.jsx)(n.h2,{children:"Dates"}),"\n",(0,o.jsxs)(n.p,{children:["Please prefer ",(0,o.jsx)(n.a,{href:"https://date-fns.org",children:"date-fns"})," over ",(0,o.jsx)(n.code,{children:"moment"})," to handle your date calculations and formatting, because ",(0,o.jsx)(n.code,{children:"date-fns"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"functional approach"}),"\n",(0,o.jsx)(n.li,{children:"immutable structure"}),"\n",(0,o.jsxs)(n.li,{children:["uses the browses native ",(0,o.jsx)(n.code,{children:"Date"})," object as the basis"]}),"\n",(0,o.jsx)(n.li,{children:"strong and consistent API"}),"\n",(0,o.jsx)(n.li,{children:"very modular"}),"\n",(0,o.jsx)(n.li,{children:"good and flexible locales support"}),"\n",(0,o.jsx)(n.li,{children:"supports three shaking"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{children:"React"}),"\n",(0,o.jsx)(n.h3,{children:"Handling of React State"}),"\n",(0,o.jsxs)(n.p,{children:["Kent C. Dodds has a good ",(0,o.jsx)(n.a,{href:"https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster",children:"article on when and where to put React State"})," with ",(0,o.jsx)(n.a,{href:"https://res.cloudinary.com/kentcdodds-com/image/upload/v1625033349/kentcdodds.com/content/blog/state-colocation-will-make-your-react-app-faster/where-to-put-state.png",title:"This chart shows the when and where to put React State",children:"this chart"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Please avoid having logic in your JSX syntax. Even it is possible to have a lot of logic in JSX because of the functional architecture, rather enforce using React Context to hide logic."}),"\n",(0,o.jsx)(n.h3,{children:"Readable JSX"}),"\n",(0,o.jsx)(n.p,{children:"Small components are readable regardless. But once a Component gets large, things changes. Therefore I (Tobias HÃ¸egh) thought a lot about how to make larger components readable. So here is my approach:"}),"\n",(0,o.jsxs)(n.p,{children:["Think of laying out your markup like reading a book. Yes, ",(0,o.jsx)(n.strong,{children:"reading a book"}),".\nYou have your;"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"intro"}),"\n",(0,o.jsx)(n.li,{children:"content"}),"\n",(0,o.jsx)(n.li,{children:"summary"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"So, what if you put your main markup on top? following by the content, and as a settlement to the content, we follow up with the logic? Then we get these three topics."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Main component"}),"\n",(0,o.jsx)(n.li,{children:"Sub components"}),"\n",(0,o.jsx)(n.li,{children:"Logic"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The good thing about this is, we get quickly an overview what the component contains. Here is an example using a ",(0,o.jsx)(n.em,{children:"form"})," as our basis:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"// 1. Readable markup\nconst App = () => (\n  <FormLogic>\n    <FormOne />\n    <FormTwo />\n    ...\n  </FormLogic>\n)\n\n// 2. One of the forms\nconst FormOne = () => {\n  // using the extendable Context\n  const { clickHandler } = React.useContext(FormContext)\n\n  return <Button on_click={clickHandler} />\n}\n\n// 3. And the logic, providing the Context\nconst FormLogic = (props) => {\n  // Here we have our logic\n  function clickHandler() {}\n\n  // Our context we use for state handling etc.\n  const formContext = {\n    clickHandler,\n  }\n\n  return <FormContext.Provider value={formContext} {...props} />\n}\nconst FormContext = React.createContext({})\n"})})]})}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,s.R)(),e.components);return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(r,e)})):r(e)}}}]);
//# sourceMappingURL=component---src-docs-uilib-usage-best-practices-for-javascript-mdx-47590bc63932f6f8b9be.js.map