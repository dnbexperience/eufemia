---
title: 'Create your own component'
order: 5
breadcrumb:
  - text: Forms
    href: /uilib/extensions/forms/
  - text: Create your component
    href: /uilib/extensions/forms/create-component/
---

import ListBasisAPIs from './create-component/ListBasisAPIs'
import {
  CreateBasicFieldComponent,
  CreateComposedFieldComponent,
} from './Examples'

# Create your own component

Eufemia Forms contains helper fields and tools so you can declaratively create interactive form components that flawlessly integrates between existing data and your custom form components.

By using the building blocks for field components, you save development time, and at the same time ensure that local, custom components work similarly, and fit into the setup with [the standardized field components](/uilib/extensions/forms/base-fields/).

```jsx
import {
  DataContext,
  Field,
  FieldBlock,
  Iterate,
  Value,
  ValueBlock,
  Visibility,
  useDataValue,
} from '@dnb/eufemia/extensions/forms'
```

## More details

Here is an example of a custom component. Notice how the props received by your field component are passed through the `useDataValue` hook. This hook does not change the API of the props, so the props returned by the hook share the same typescript type with which it was called. However, it adds a few additional properties to simplify the standardization of field behavior. This in the form of the handler functions `handleFocus`, `handleChange` and `handleBlur`. Even if field components externally have these callback functions named with "on" (eg "onChange"), these will remain untouched, while the "handle" variants add handling that saves you a lot of extra work.

<CreateBasicFieldComponent />

### The example explained

In the example above, you see how you can create your own user input functionality in a standardized context using `FieldBlock`. This allows you to display labels, error messages and other surrounding elements in a consistent manner with the ready-made fields found in Eufemia Forms.

When you call these three functions as used above from your own implementation of the user experience for the field component, a lot will happen in the background. All available validation functions will be called at the right time, changes in value will be synchronized with any surrounding `DataContext`, co-operation between several fields that should display error messages collectively instead of individually, and not least it ensures that error messages are not displayed on unnecessary times such as while the user is making changes to the field.

Remember that everything that happens by using `useDataValue` and the rest of the available helper functionality, you can override the behavior individually to make the component work exactly as you want.

### Your own validation

If – for example; you need to carry out your own custom validation and cannot use the built-in validation with a JSON Schema or by sending in a derivative validator (as is done in the example above), you can write your own logic for it, and send the result in as props to `FieldBlock` in the form of `error`. All direct props override standard handling, so you have full control over your component.

### Customized even further

If you need something that looks even more different than the usual fields, you can drop `FieldBlock` and display surrounding elements in other ways – but still get all the help of a data flow logic, such as `useDataValue` offers.

Here follows an example that retrieves data from a surrounding DataContext, and creates a composite field based on other components from Eufemia:

<CreateComposedFieldComponent />

## Layout

When building your custom form components, preferably use the [Layout](/uilib/layout) component.

### Width definitions

These are the official sizes you can use when [creating your own form fields](/uilib/extensions/forms/create-component/).

```css
:root {
  --forms-field-width--small: 5rem;
  --forms-field-width--medium: 11rem;
  --forms-field-width--large: 21rem;
}
```

You can also use a [FieldBlock](/uilib/extensions/forms/create-component/FieldBlock/) and provide a `width` prop with a value of either `small`, `medium` or `large` and use it as a sized wrapper.

## Components

<ListBasisAPIs />

---

## Hooks

### useDataValue

The `useDataValue` hook standardize handling of the value flow for a single consumer component representing one data point. It holds error state, hides it while the field is in focus, connects to surrounding `DataContext` (if present) and other things that all field or value components needs to do. By implementing custom field or value components and passing the received props through `useDataValue`, all these features work the same way as other field or value components, and you only need to implement the specific unique features of that component.

How to use:

```ts
const { value } = useDataValue(componentProps)
```

Advanced usage:

```ts
const {
  // Return Parameters:
  value,
  onChange,
  onFocus,
  onBlur,
  error,
  hasError,
  isChanged,
  setHasFocus,

  // Component Properties
  ...rest
} = useDataValue({
  // Your Component Properties:
  ...componentProps,

  // Internal Properties, listed down below:
  required,
  errorMessages,
})
```

#### Internal Properties

All properties are optional and can be used as needed. These properties can be provided as part of your component properties.

- `value` the input value (string).
- `emptyValue` defines what value is considered to be empty. Defaults to `undefined`. But an empty string is also validated when required is true.
- `path` the JSON pointer that defines the entry name/key in the data structure.

**Validation**

- `required` if true, it will call `validateRequired` for validation.
- `schema` or `pattern` for JSON schema validation powered by [ajv](https://ajv.js.org/).
- `validator` your custom validation function. It will run on every keystroke.
- `validateRequired` does allow you to provide a custom logic for how the `required` prop should validate.
- `onBlurValidator` your custom validation function. It will run on a `handleBlur()` call. Use it over `validator` for validations with side-effects.
- `validateInitially` in order to show an error without a change and blur event. Used for rare cases.
- `validateUnchanged` in order to validate without a change and blur event. Used for rare cases.
- `continuousValidation` in order to validate without a focus event beforehand. Used for rare cases.

**Error**

- `error` object like `FormError` that includes the string to display or an object with the key `validationRule`. More info down below.
- `errorMessages` object with your custom messages, where each key represents a `validationRule`. More info down below.

#### Return Parameters

It returns all of the given component properties, in addition to these:

- `value` the output value.
- `id` creates a memorized id.
- `dataContext` the internal shared data context.
- `error` the error object, in case an error is invoked. Will skip returning the error object, if the hook is used in a nested [FieldBlock](/uilib/extensions/forms/create-component/FieldBlock/).
- `hasError` will return true in case of an error, even if the hook is nested in a `FieldBlock`.
- `isChanged` returns `true` if the value has changed with e.g. `handleChange`.
- `setHasFocus` accepts a boolean as value. When called, it will update the internal logic - for event handling and validation. Will re-render the React Hook and its outer component.
- `onFocus` event handler to assign to a form element.
- `onBlur` event handler to assign to a form element.
- `onChange` event handler to assign to a form element.

#### Custom validateRequired

```ts
const validateRequired = (
  value: Value,
  { emptyValue, required, isChanged },
) => {
  return required && value === emptyValue
    ? new FormError('The value is required', {
        validationRule: 'required',
      })
    : undefined
}

const { error, hasError } = useDataValue({
  value: undefined,
  required: true,
  validateInitially: true,
  validateRequired,
  errorMessages: {
    required: 'Show this when "required" fails!',
  },
})
```

##### Validation order

During validation, the different APIs do have a prioritization order and will stop processing further when they match:

1. `required` prop
1. `schema` prop (including `pattern`)
1. `validator` prop

#### Error handling

Validation and error-handling is tight coupled together. When a validation fails, you may use the error-object to handle and show the failures/statuses.

To generate the error-object, `FormError` is used. You can use it as well:

```tsx
import { FormError } from '@dnb/eufemia/extensions/forms'
render(
  <Field.String
    label="Label"
    warning={new FormError("I'm a warning too...")}
  />,
)
```

But when you handle errors via `useDataValue`, you may rather provide an object with messages, which will be used to display the error:

```ts
const { error, hasError } = useDataValue({
  required: true,
  errorMessages: {
    required: 'Show this when "required" fails!',
  },
  ...componentProps,
})
```

In order to invoke an error without a change and blur event, you can use `validateInitially`:

```ts
const { error, hasError } = useDataValue({
  value: undefined,
  required: true,
  validateInitially: true,
  errorMessages: {
    required: 'Show this when "required" fails!',
  },
})
```

#### Event handlers

- `handleFocus()` to call the `onFocus` event.

- `handleBlur()` to call the `onBlur` event.

- `handleChange(value)` to call the `onChange` event. Will update/change the internal value and re-render the React Hook, so will the outer component too.

```ts
handleChange(value, (additionalArgs = null))
```

- `updateValue(value)` to update/change the internal value, without calling any events.

- `forceUpdate()` to re-render the React Hook along with the outer component.

#### Value transformers

The transformers are hooks to transform the value on different stages.

They should return a transformed value: `(value) => value`

- `toInput` transforms the value before it gets returned by the hook:

```ts
const { value } = useDataValue(props)
```

- `fromInput` transforms the value given by `handleChange` before it is used in the further process flow.

```ts
handleChange(value)
```

- `toEvent` transforms the internal value before it gets returned by even callbacks such as `onChange`, `onFocus` and `onBlur`.

- `fromExternal` transforms the given props `value` before any other step gets entered.
