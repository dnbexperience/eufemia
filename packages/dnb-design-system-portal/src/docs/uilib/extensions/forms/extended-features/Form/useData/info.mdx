---
showTabs: true
---

## Description

With the `Form.useData` hook, you can manage your form data outside of the form component itself. This is beneficial when you need to utilize the form data in other places within your application:

```jsx
import { Form } from '@dnb/eufemia/extensions/forms'

function Component() {
  const { data } = Form.useData('unique')

  return <Form.Handler id="unique">...</Form.Handler>
}
```

You link them together via the `id` (string) property.

TypeScript support:

```tsx
type Data = { foo: string }
const { data } = Form.useData<Data>('unique')
```

## Initial data

You decide where and when you want to provide the initial `data` to the form. It can be done via the `Form.Handler` component, or via the `Form.useData` Hook â€“ or even in each Field, with the value property.

```jsx
import { Form, Field } from '@dnb/eufemia/extensions/forms'

function Component() {
  const { data } = Form.useData('unique', { foo: 'bar' })

  return (
    <Form.Handler id="unique">
      <Field.String path="/foo" />
    </Form.Handler>
  )
}
```

## Update data

If you need to update the data, you can use the `update` method.

It takes a path ([JSON Pointer](/uilib/extensions/forms/getting-started/#what-is-a-json-pointer)) and a callback function. The callback function receives the existing value as the first argument, and the second argument is the path itself. The callback function must return the new value.

```jsx
import { Form } from '@dnb/eufemia/extensions/forms'

function Component() {
  const { update } = Form.useData('unique', { foo: 'bar' })

  useEffect(() => {
    update('/foo', () => 'new value')
    // or
    update('/foo', (existingValue) => existingValue + 'new value')
  }, [])
}
```

The `update` function has TypeScript support and returns the correct type for `existingValue`.

## Extend the whole data set

With the `set` method, you can extend the data set. Existing data paths will be overwritten.

```jsx
import { Form, Field } from '@dnb/eufemia/extensions/forms'

function Component() {
  const { data, set } = Form.useData('unique')

  useEffect(() => {
    set({ foo: 'bar' })
  }, [])

  return (
    <Form.Handler id="unique">
      <Field.String path="/foo" />
    </Form.Handler>
  )
}
```

## Filter data

You can use the `filterData` method to filter your data.

You simply give it the same kind of callback function as you would with the `Form.Handler` [filterData](/uilib/extensions/forms/extended-features/Form/Handler/demos/#filter-your-data) property method.

The callback function receives the path as the first argument, the value as the second argument, and the related field properties as the third argument. The callback function must return a boolean value or undefined. Return false to exclude an entry.

It returns the filtered form data.

```tsx
const filterDataHandler = (path, value, props) => {
  if (props.disabled === true) {
    return false
  }
}

const Component = () => {
  const { data, filterData } = Form.useData(id)

  const filteredData = filterData(filterDataHandler)

  return (
    <Form.Handler id={id}>
      <Field.String path="/foo" disabled />
    </Form.Handler>
  )
}
```
