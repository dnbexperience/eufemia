/*
 * Utilities
 * ========================================================================== */

// Mobile-first media query helper
@mixin media($bp) {
  @media screen and (min-width: #{$bp}) {
    @content;
  }
}

// Font smoothing mixin
// Only use for light text on dark background
// @mixin fontSmoothing {
//   -moz-osx-font-smoothing: grayscale;
//   -webkit-font-smoothing: antialiased;
// }

@mixin numberFeature($variant, $setting) {
  font-variant-numeric: $variant;
  font-feature-settings: '#{$setting}';
}

// @mixin navActive() {
//   [data-nav-active='true'] & {
//     @content;
//   }
// }

//Uses .no-touch and .touch
//classes on <body> element
//based on js touch device test
@mixin hover($nested) {
  @if $nested {
    .no-touch & {
      &:hover {
        &[disabled] {
          cursor: not-allowed;
        }
        &:not([disabled]) {
          @content;
        }
      }
    }
  } @else {
    .no-touch {
      &:hover {
        &[disabled] {
          cursor: not-allowed;
        }
        &:not([disabled]) {
          @content;
        }
      }
    }
  }
}

@mixin fakeFocus(
  $whatinput: 'keyboard',
  $color: var(--color-signal-orange)
) {
  outline: none;

  html[data-whatinput='#{$whatinput}'] & {
    @include fakeBorder($color);
  }
}

@mixin fakeBorder($color: null, $shadow: null, $important: null) {
  // we use !important, cause we have no changes to select the selctor right
  // in some cases we have another state where we use box-shadow
  // but with important, we take care of that we actually can use use it
  @if $shadow {
    box-shadow: $shadow $important;
  } @else {
    box-shadow: 0 0 0 2px $color $important;
  }

  @if $color != null {
    border-color: transparent;
  }
}

@mixin _drawUnderline() {
  content: '';
  position: absolute;
  z-index: -1;
  left: 0.1em;
  right: 0.1em;

  width: auto;
  height: 100%;

  @content;
}

@mixin drawUnderlineBackground() {
  // bg
  &::before {
    @include _drawUnderline() {
      left: 0.1em;
      right: 0.1em;
      bottom: 0;

      max-height: 0%;
      transition: max-height 0.1s ease-out;

      // to make the transition show reverse, we have to define the color here
      background-color: var(--color-mint-green-50);

      @content;
    }
  }
}

@mixin drawUnderlineBorder() {
  // border
  &::after {
    @include _drawUnderline() {
      left: 0.05em;
      right: 0.05em;
      bottom: 0;
      height: 1px;
    }

    // transition: left 0.1s linear 0.1s, right 0.1s linear 0.1s;

    border-radius: 0.5px;
    border-bottom: 1px solid var(--color-sea-green);

    @content;
  }
}

// TODO: considder to take all below out

$breakpoints: (
  'small': 320px,
  'medium': 700px,
  'large': 1024px,
  'xLarge': 1400px
);

//Example usage:
//@include allAbove(phone){ styles go here.. }
@mixin allAbove($size) {
  @media screen and (min-width: map-get($breakpoints, $size)) {
    @content;
  }
}
@mixin allBelow($size) {
  @media screen and (max-width: map-get($breakpoints, $size)) {
    @content;
  }
}
@mixin nudger($direction, $nudge) {
  @if $direction == 'horizontal' {
    width: #{$nudge}rem;
  }
  @if $direction == 'vertical' {
    height: #{$nudge}rem;
  }
}
// Unstyled list helper
@mixin unstyledList() {
  margin: 0;
  list-style-type: none;
  padding-left: 0;

  > li {
    margin-bottom: 0;
  }
}

// Screen reader only helper
@mixin sr-only() {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

// This "negates" the sr-only() helper; useful if
// we want the default state of something to be
// for screen readers only, but we want to force
// it to show for sighted users under more specific
// conditions.
@mixin notSrOnly() {
  position: static;
}

@function str-replace($string, $search, $replace: '') {
  $index: str-index($string, $search);

  @if $index {
    @return str-slice($string, 1, $index - 1) + $replace +
      str-replace(
        str-slice($string, $index + str-length($search)),
        $search,
        $replace
      );
  }

  @return $string;
}
